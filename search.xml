<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>作用域</title>
      <link href="/2018/09/07/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/2018/09/07/%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 this 的值，也被称为 This Binding。</p><p>2、LexicalEnvironment（词法环境） 组件被创建。</p><p>3、VariableEnvironment（变量环境） 组件被创建。<br>直接看伪代码可能更加直观</p><p>ExecutionContext = {<br>  ThisBinding = <this value>,     // 确定this<br>  LexicalEnvironment = { … },   // 词法环境<br>  VariableEnvironment = { … },  // 变量环境<br>}<br>This Binding<br>全局执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window 对象，而在nodejs中指向这个文件的module对象。</this></p><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数，具体内容会在【this全面解析】部分详解。</p><p>词法环境（Lexical Environment）<br>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><p>变量环境<br>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>1.变量提升</p><pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li><p>2.函数提升</p><pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p></li></ul><p>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><p><strong>内存回收</strong></p><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><p>垃圾回收算法</p><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><p><strong>引用计数</strong></p><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><p><strong>标记清除（常用）</strong></p><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）<br><strong>内存泄漏识别方法</strong></p><ul><li>1、<strong>浏览器方法</strong><br>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li><li>2、<strong>命令行方法</strong><br>使用 Node 提供的 process.memoryUsage 方法。<pre><code>console.log(process.memoryUsage());// 输出{ rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的heapUsed: 3449392,    // 用到的堆的部分external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre>判断内存泄漏，以heapUsed字段为准。</li></ul><p><strong>WeakMap</strong></p><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><p><strong>四种常见的JS内存泄漏</strong></p><p>1、<strong>意外的全局变量</strong></p><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><p>2、<strong>被遗忘的计时器或回调函数</strong></p><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><p>3、<strong>脱离 DOM 的引用</strong></p><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><p>4.<strong>闭包</strong></p><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行栈 </tag>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2018/09/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</p><h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p>typeof 对于基本类型，除了 null 都可以显示正确的类型<br><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c6ee7529bae2d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>000 开头代表是对象，然而 null 表示 为全零，所以将它错误的判断为 object 。</p><h2 id="instanceof-和-Object-prototype-toString-call"><a href="#instanceof-和-Object-prototype-toString-call" class="headerlink" title="instanceof 和 Object.prototype.toString.call"></a>instanceof 和 Object.prototype.toString.call</h2><p>typeof 无法判断数组，对象.<br>可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[Object Type]</code> 的字符串。<br><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 <code>prototype</code>。</p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li><code>ToString</code>负责处理非字符串到字符串的强制类型转换<br>null转换为’null’,undefined转换为’undefined’,其他基本类型都调用基本类型的包装对象属性toString()并返回值。<pre><code>const a = 123; const _a = new Number(123); console.log(String(a), _a.toString());               //&#39;123&#39; &#39;123&#39; 数字的字符串化遵循通用规则，但是极小极大数字使用指数形式const a = 1.07*1000*1000*1000*1000*1000*1000*1000;console.log(String(a));                               //&#39;1.07e+21&#39;</code></pre>对于普通对象来说，除非自行定义，否则<code>toString()</code>返回<code>Object.prototype.toString()</code>的值,其他对象有自己的<code>toString()</code>方法则调用自己的该方法.<pre><code>const b = {};console.log(String(b));                                //[object object]</code></pre>对于数组来说会转成以“，”拼接各项的字符串<pre><code>const arr = [{s:1},2,3]console.log(arr.toString())                           //&quot;[object Object],2,3&quot;</code></pre></li><li><code>ToNumber</code>负责处理非数字到数字的强制类型转换</li></ul><p>true转换为1，false转换为0，undefined转换为NaN，null转换为0</p><pre><code>console.log(Number(null));                                //0 console.log(Number(undefined));                           //NaNconsole.log(Number(true));                                //1console.log(Number(false));                               //0</code></pre><p>对字符串的处理遵循数字常量的相关规定/语法，处理失败时返回NaN</p><pre><code>console.log(Number(&#39;123&#39;));                               //123console.log(Number(&#39;0b111&#39;));                             //7console.log(Number(&#39;0o123&#39;));                             //83console.log(Number(&#39;0x123&#39;));                             //291console.log(Number(&#39;123a&#39;));                              //NaNconsole.log(Number(&#39;a123&#39;));                              //NaN</code></pre><p>对象（包括数组）会首先按照<code>ToPrimitive</code>抽象操作被转换为相应的基本类型值，再按照前两条规则处理；如果某个对象即不存在<code>valueOf</code>方法也不存在<code>toString</code>方法，则会产生<code>TypeError</code>错误（例如Object.create(null)不存在以上两种方法）</p><pre><code>const arr = [1, 2, 3]; console.log(Number(arr));                               //NaNconsole.log(Number(arr.toString()));                    //NaNconst num = new Number(123);console.log(Number(num));                               //123console.log(Number(num.valueOf()));                     //123const bool = new Boolean(true);console.log(bool.valueOf());                           //trueconsole.log(Number(bool));                             //1console.log(Number(bool.valueOf()));                   //1const obj1 = {  toString:()=&gt;&quot;21&quot;}const obj2 = {  valueOf:()=&gt;&quot;42&quot;,  toString:()=&gt;&quot;21&quot;}const obj3 = {  a:1}console.log(Number(obj1));                              //21console.log(Number(obj2));                              //42console.log(obj3.toString());                           //[object Object]console.log(Number(obj3));                              //NaNconst obj = Object.create(null);console.log(Number(obj));                               //TypeError</code></pre><ul><li><code>ToBoolean</code>负责处理非布尔值到布尔值的强制类型转换，规则如下</li></ul><p>可以被转换为<code>false</code>的值（<code>undefined</code>，<code>null</code>，<code>false</code>， <code>0</code>和<code>NaN</code>，’’）</p><p>其他都被转换为true（切记：封装对象均被转为true）</p><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换为字符串</p><p>一元运算符加号（+）首先把非基本类型通过ToPrimitive抽象操作转换为基本类型，如果加号中的两项有一项是字符串，另一项则进行ToString操作，进行字符串拼接，如果是布尔值加数字，则对布尔进行ToNumber操作再求和</p><p>隐式强制类型转换为数字，通过一元运算符-、/、*转换，遵循ToNumber的抽象值操作规则</p><p>隐式强制类型转换为布尔值</p><p>if(..)语句中的条件判断表达式</p><p>for(..;..;..)语句的第二个条件判断表达式</p><p>while(..)和do..while(..)的条件判断表达式</p><p>?:中的条件判断表达式</p><p>逻辑运算符||和&amp;&amp;左边的操作数（a||b等同于a?a:b，a&amp;&amp;b等同于a?b:a）</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
