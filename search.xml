<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解JS异步</title>
      <link href="/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5/"/>
      <url>/2019/10/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/wangfupeng1988" target="_blank" rel="noopener">本文出自</a></p><h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><h3 id="JS-为何会有异步"><a href="#JS-为何会有异步" class="headerlink" title="JS 为何会有异步"></a>JS 为何会有异步</h3><p>首先记住一句话 —— <strong>JS 是单线程的语言</strong>，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，上面的执行为完成，就傻傻的等着。例如</p><pre><code>var i, t = Date.now()for (i = 0; i &lt; 100000000; i++) {}console.log(Date.now() - t)  // 308 （chrome浏览器）</code></pre><p>上面的程序花费 308ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。</p><p>执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的 js ，可能会有大量的网络请求，而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？———— 那肯定不行。</p><p>因此，JS 对于这种场景就设计了异步 ———— 即，<strong>发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说</strong>。这样就能保证一个网页的流程运行。</p><h3 id="异步的实现原理"><a href="#异步的实现原理" class="headerlink" title="异步的实现原理"></a>异步的实现原理</h3><p>先看一段比较常见的代码</p><pre><code>var ajax = $.ajax({    url: &#39;/data/data1.json&#39;,    success: function () {        console.log(&#39;success&#39;)    }})</code></pre><p>上面代码中<code>$.ajax()</code>需要传入两个参数进去，url和success，其中url是请求的路由，success是一个函数。<strong>这个函数传递过去不会立即执行，而是等着请求成功之后才能执行</strong>。对于这种传递过去不执行，等出来结果之后再执行的函数，叫做callback，即<strong>回调函数</strong></p><p>再看一段更加能说明回调函数的 nodejs 代码。和上面代码基本一样，唯一区别就是：上面代码时网络请求，而下面代码时 IO 操作。</p><p>var fs = require(‘fs’)<br>fs.readFile(‘data1.json’, (err, data) =&gt; {<br>    console.log(data.toString())<br>})<br>从上面两个 demo 看来，实现异步的最核心原理，就是<strong>将callback作为参数传递给异步执行函数，当有结果返回之后再触发 callback执行</strong>，就是如此简单！</p><h3 id="常用的异步操作"><a href="#常用的异步操作" class="headerlink" title="常用的异步操作"></a>常用的异步操作</h3><p>开发中比较常用的异步操作有：</p><ul><li>网络请求，如ajax http.get</li><li>IO 操作，如readFile readdir</li><li>定时函数，如setTimeout setInterval</li></ul><h2 id="jQuery-1-5-之后的-ajax"><a href="#jQuery-1-5-之后的-ajax" class="headerlink" title="jQuery-1.5 之后的 ajax"></a>jQuery-1.5 之后的 ajax</h2><p><code>$.ajax</code>这个函数各位应该都比较熟悉了，要完整的讲解 js 的异步操作，就必须先从$.ajax这个方法说起。</p><h3 id="传统的-ajax"><a href="#传统的-ajax" class="headerlink" title="传统的$.ajax"></a>传统的$.ajax</h3><p>先来一段最常见的$.ajax的代码，当然是使用万恶的callback方式</p><pre><code>var ajax = $.ajax({    url: &#39;data.json&#39;,    success: function () {        console.log(&#39;success&#39;)    },    error: function () {        console.log(&#39;error&#39;)    }})console.log(ajax) // 返回一个 XHR 对象</code></pre><p>至于这么做会产生什么样子的诟病，我想大家应该都很明白了。不明白的自己私下去查，但是你也可以继续往下看，你只需要记住这样做很不好就是了，要不然 jquery 也不会再后面进行改进</p><h3 id="1-5-版本之后的-ajax"><a href="#1-5-版本之后的-ajax" class="headerlink" title="1.5 版本之后的$.ajax"></a>1.5 版本之后的$.ajax</h3><p>但是从v1.5开始，以上代码就可以这样写了：可以链式的执行done或者fail方法</p><pre><code>var ajax = $.ajax(&#39;data.json&#39;)ajax.done(function () {    console.log(&#39;success 1&#39;)}).fail(function () {    console.log(&#39;error&#39;)}).done(function () {        console.log(&#39;success 2&#39;)})console.log(ajax) // 返回一个 deferred 对象</code></pre><p>大家注意看以上两段代码中都有一个console.log(ajax)，但是返回值是完全不一样的。</p><p>v1.5之前，返回的是一个XHR对象，这个对象不可能有done或者fail的方法的<br>v1.5开始，返回一个deferred对象，这个对象就带有done和fail的方法，并且是等着请求返回之后再去调用</p><h3 id="改进之后的好处"><a href="#改进之后的好处" class="headerlink" title="改进之后的好处"></a>改进之后的好处</h3><p>这是一个标志性的改造，不管这个概念是谁最先提出的，它在 jquery 中首先大量使用并让全球开发者都知道原来 ajax 请求还可以这样写。这为以后的Promise标准制定提供了很大意义的参考，你可以以为这就是后面Promise的原型。</p><p>记住一句话————<strong>虽然 JS 是异步执行的语言，但是人的思维是同步的</strong>————因此，开发者总是在寻求如何使用逻辑上看似同步的代码来完成 JS 的异步请求。而 jquery 的这一次更新，让开发者在一定程度上得到了这样的好处。</p><p>之前无论是什么操作，我都需要一股脑写到callback中，现在不用了。现在成功了就写到done中，失败了就写到fail中，如果成功了有多个步骤的操作，那我就写很多个done，然后链式连接起来就 OK 了。</p><h3 id="和后来的Promise的关系"><a href="#和后来的Promise的关系" class="headerlink" title="和后来的Promise的关系"></a>和后来的Promise的关系</h3><p>以上的这段代码，我们还可以这样写。即不用done和fail函数，而是用then函数。then函数的第一个参数是成功之后执行的函数（即之前的done），第二个参数是失败之后执行的函数（即之前的fail）。而且then函数还可以链式连接。</p><pre><code>var ajax = $.ajax(&#39;data.json&#39;)ajax.then(function () {    console.log(&#39;success 1&#39;)}, function () {    console.log(&#39;error 1&#39;)}).then(function () {    console.log(&#39;success 2&#39;)}, function () {    console.log(&#39;error 2&#39;)})</code></pre><h2 id="jQuery-deferred"><a href="#jQuery-deferred" class="headerlink" title="jQuery deferred"></a>jQuery deferred</h2><h3 id="写一个传统的异步操作"><a href="#写一个传统的异步操作" class="headerlink" title="写一个传统的异步操作"></a>写一个传统的异步操作</h3><p>给出一段非常简单的异步操作代码，使用setTimeout函数。</p><pre><code>var wait = function () {    var task = function () {        console.log(&#39;执行完成&#39;)    }    setTimeout(task, 2000)}wait()</code></pre><p>以上这些代码执行的结果大家应该都比较明确了，即 2s 之后打印出执行完成。但是我如果再加一个需求 ———— 要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤 ———— 那该怎么办？ 大家思考一下！</p><p>如果你不看下面的内容，而且目前还没有Promise的这个思维，那估计你会说：直接在task函数中写就是了！不过相信你看完下面的内容之后，会放弃你现在的想法。</p><h3 id="使用-Deferred封装"><a href="#使用-Deferred封装" class="headerlink" title="使用$.Deferred封装"></a>使用$.Deferred封装</h3><p>好，接下来我们让刚才简单的几行代码变得更加复杂。为何要变得更加复杂？是因为让以后更加复杂的地方变得简单。这里我们使用了 jquery 的<code>$.Deferred</code>，至于这个是个什么鬼，大家先不用关心，只需要知道<code>$.Deferred()</code>会返回一个deferred对象，先看代码，deferred对象的作用我们会面会说。</p><pre><code>function waitHandle() {    var dtd = $.Deferred()  // 创建一个 deferred 对象    var wait = function (dtd) {  // 要求传入一个 deferred 对象        var task = function () {            console.log(&#39;执行完成&#39;)            dtd.resolve()  // 表示异步任务已经完成        }        setTimeout(task, 2000)        return dtd  // 要求返回 deferred 对象    }    // 注意，这里一定要有返回值    return wait(dtd)}</code></pre><p>以上代码中，又使用一个waitHandle方法对wait方法进行再次的封装。waitHandle内部代码，我们分步骤来分析。跟着我的节奏慢慢来，保证你不会乱。</p><ul><li>使用var dtd = $.Deferred()创建deferred对象。通过上一节我们知道，一个deferred对象会有done fail和then方法（不明白的去看上一节）</li><li>重新定义wait函数，但是：第一，要传入一个deferred对象（dtd参数）；第二，当task函数（即callback）执行完成之后，要执行dtd.resolve()告诉传入的deferred对象，革命已经成功。第三；将这个deferred对象返回。</li><li>返回wait(dtd)的执行结果。因为wait函数中返回的是一个deferred对象（dtd参数），因此wait(dtd)返回的就是dtd————如果你感觉这里很乱，没关系，慢慢捋，一行一行看，相信两三分钟就能捋顺！   </li></ul><p>最后总结一下，waitHandle函数最终return wait(dtd)即最终返回dtd（一个deferred）对象。针对一个deferred对象，它有done fail和then方法（上一节说过），它还有resolve()方法（其实和resolve相对的还有一个reject方法，后面会提到）</p><h3 id="应用then方法"><a href="#应用then方法" class="headerlink" title="应用then方法"></a>应用then方法</h3><p>接着上面的代码继续写</p><pre><code>var w = waitHandle()w.then(function () {    console.log(&#39;ok 1&#39;)}, function () {    console.log(&#39;err 1&#39;)}).then(function () {    console.log(&#39;ok 2&#39;)}, function () {    console.log(&#39;err 2&#39;)})</code></pre><p>上面已经说过，waitHandle函数最终返回一个deferred对象，而deferred对象具有done fail then方法，现在我们正在使用的是then方法。至于then方法的作用，我们上一节已经讲过了，不明白的同学抓紧回去补课。</p><p>执行这段代码，我们打印出来以下结果。可以将结果对标以下代码时哪一行。</p><pre><code>执行完成ok 1ok 2</code></pre><p>此时，你再回头想想我刚才说提出的需求（要在执行完成之后进行某些特别复杂的操作，代码可能会很多，而且分好几个步骤），是不是有更好的解决方案了？</p><p>有同学肯定发现了，代码中<code>console.log(&#39;err 1&#39;)和console.log(&#39;err 2&#39;)</code>什么时候会执行呢 ———— 你自己把waitHandle函数中的<code>dtd.resolve()</code>改成<code>dtd.reject()</code>试一下就知道了。</p><p><code>dtd.resolve()</code> 表示革命已经成功，会触发then中第一个参数（函数）的执行，<br><code>dtd.reject()</code> 表示革命失败了，会触发then中第二个参数（函数）执行</p><p>总结一下一个deferred对象具有的函数属性，并分为两组：</p><ul><li>dtd.resolve dtd.reject</li><li>dtd.then dtd.done dtd.fail</li></ul><p>我为何要分成两组 ———— 这两组函数，从设计到执行之后的效果是完全不一样的。第一组是主动触发用来改变状态（成功或者失败），第二组是状态变化之后才会触发的监听函数。</p><h2 id="jQuery-promise"><a href="#jQuery-promise" class="headerlink" title="jQuery promise"></a>jQuery promise</h2><h3 id="返回promise"><a href="#返回promise" class="headerlink" title="返回promise"></a>返回promise</h3><p>我们对上一节的的代码做一点小小的改动，只改动了一行，下面注释。</p><pre><code>function waitHandle() {    var dtd = $.Deferred()    var wait = function (dtd) {        var task = function () {            console.log(&#39;执行完成&#39;)            dtd.resolve()        }        setTimeout(task, 2000)        return dtd.promise()  // 注意，这里返回的是 primise 而不是直接返回 deferred 对象    }    return wait(dtd)}var w = waitHandle() // 经过上面的改动，w 接收的就是一个 promise 对象$.when(w) .then(function () {    console.log(&#39;ok 1&#39;) }) .then(function () {    console.log(&#39;ok 2&#39;) })</code></pre><p>改动的一行在这里return dtd.promise()，之前是return dtd。dtd是一个deferred对象，而dtd.promise就是一个promise对象。</p><p>promise对象和deferred对象最重要的区别，记住了————<strong>promise对象相比于deferred对象，缺少了.resolve和.reject这俩函数属性</strong>。这么一来，可就完全不一样了。</p><p>上一节我们提到一个问题，就是在程序的最后一行加一句<code>w.reject()</code>会导致乱套，你现在再在最后一行加<code>w.reject()</code>试试 ———— 保证乱套不了 ———— 而是你的程序不能执行，直接报错。因为，w是promise对象，不具备<code>.reject</code>属性。</p><h3 id="返回promise的好处"><a href="#返回promise的好处" class="headerlink" title="返回promise的好处"></a>返回promise的好处</h3><p>上一节提到deferred对象有两组属性函数，而且提到应该把这两组彻底分开。现在通过上面一行代码的改动，就分开了。</p><ul><li>waitHandle函数内部，使用<code>dtd.resolve()</code>来该表状态，做主动的修改操作</li><li>waitHandle最终返回promise对象，只能去被动监听变化（then函数），而不能去主动修改操作<br>一个“主动”一个“被动”，完全分开了。</li></ul><h3 id="promise-的概念"><a href="#promise-的概念" class="headerlink" title="promise 的概念"></a>promise 的概念</h3><p>jquery v1.5 版本发布时间距离现在已经老早之前了，那会儿大家网页标配都是 jquery 。无论里面的deferred和promise这个概念和想法最早是哪位提出来的，但是最早展示给全世界开发者的是 jquery ，这算是Promise这一概念最先的提出者。</p><p>其实本次课程主要是给大家分析 ES6 的Promise Generator和async-await，但是为何要从 jquery 开始（大家现在用 jquery 越来越少）？就是要给大家展示一下这段历史的一些起点和发展的知识。有了这些基础，你再去接受最新的概念会非常容易，因为所有的东西都是从最初顺其自然发展进化而来的，我们要去用一个发展进化的眼光学习知识，而不是死记硬背。</p><h2 id="Promise-加入-ES6-标准"><a href="#Promise-加入-ES6-标准" class="headerlink" title="Promise 加入 ES6 标准"></a>Promise 加入 ES6 标准</h2><h3 id="写一段传统的异步操作"><a href="#写一段传统的异步操作" class="headerlink" title="写一段传统的异步操作"></a>写一段传统的异步操作</h3><p>还是拿之前讲 jquery deferred对象时的那段setTimeout程序</p><pre><code>var wait = function () {    var task = function () {        console.log(&#39;执行完成&#39;)    }    setTimeout(task, 2000)}wait()</code></pre><p>之前我们使用 jquery 封装的，接下来将使用 ES6 的Promise进行封装，大家注意看有何不同。</p><h3 id="用Promise进行封装"><a href="#用Promise进行封装" class="headerlink" title="用Promise进行封装"></a>用Promise进行封装</h3><pre><code>const wait =  function () {    // 定义一个 promise 对象    const promise = new Promise((resolve, reject) =&gt; {        // 将之前的异步操作，包括到这个 new Promise 函数之内        const task = function () {            console.log(&#39;执行完成&#39;)            resolve()  // callback 中去执行 resolve 或者 reject        }        setTimeout(task, 2000)    })    // 返回 promise 对象    return promise}</code></pre><p>注意看看程序中的注释，那都是重点部分。从整体看来，感觉这次比用 jquery 那次简单一些，逻辑上也更加清晰一些。</p><p>将之前的异步操作那几行程序，用<code>new Promise((resolve,reject) =&gt; {.....})</code>包装起来，最后return即可<br>异步操作的内部，在callback中执行resolve()（表明成功了，失败的话执行reject）<br>接着上面的程序继续往下写。wait()返回的肯定是一个promise对象，而promise对象有then属性。</p><pre><code>const w = wait()w.then(() =&gt; {    console.log(&#39;ok 1&#39;)}, () =&gt; {    console.log(&#39;err 1&#39;)}).then(() =&gt; {    console.log(&#39;ok 2&#39;)}, () =&gt; {    console.log(&#39;err 2&#39;)})</code></pre><p>then还是和之前一样，接收两个参数（函数），第一个在成功时（触发resolve）执行，第二个在失败时(触发reject)时执行。而且，then还可以进行链式操作。</p><p>以上就是 ES6 的Promise的基本使用演示。看完你可能会觉得，这跟之前讲述 jquery 的不差不多吗 ———— 对了，这就是我要在之前先讲 jquery 的原因，让你感觉一篇一篇看起来如丝般顺滑！</p><h2 id="Promise-在-ES6-中的具体应用"><a href="#Promise-在-ES6-中的具体应用" class="headerlink" title="Promise 在 ES6 中的具体应用"></a>Promise 在 ES6 中的具体应用</h2><h3 id="Promise封装"><a href="#Promise封装" class="headerlink" title="Promise封装"></a>Promise封装</h3><p>因为以下所有的代码都会用到Promise，因此干脆在所有介绍之前，先封装一个Promise，封装一次，为下面多次应用。</p><pre><code>const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)  // 后面获取文件路径时候会用到const readFilePromise = function (fileName) {    return new Promise((resolve, reject) =&gt; {        fs.readFile(fileName, (err, data) =&gt; {            if (err) {                reject(err)  // 注意，这里执行 reject 是传递了参数，后面会有地方接收到这个参数            } else {                resolve(data.toString())  // 注意，这里执行 resolve 时传递了参数，后面会有地方接收到这个参数            }        })    })}</code></pre><p>以上代码一个一段 nodejs 代码，将读取文件的函数fs.readFile封装为一个Promise。经过上一节的学习，我想大家肯定都能看明白代码的含义，要是看不明白，你就需要回炉重造了！</p>]]></content>
      
      
      <categories>
          
          <category> 异步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> async-await </tag>
            
            <tag> Generator </tag>
            
            <tag> 任务队列 </tag>
            
            <tag> event-loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试篇之---Vue 双向绑定原理</title>
      <link href="/2019/10/29/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/2019/10/29/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向绑定 </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试篇之---计算机网络</title>
      <link href="/2019/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1、谈下你对五层网络协议体系结构的理解？"><a href="#1、谈下你对五层网络协议体系结构的理解？" class="headerlink" title="1、谈下你对五层网络协议体系结构的理解？"></a>1、谈下你对五层网络协议体系结构的理解？</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><ul><li><strong>应用层应用层（application-layer）</strong><br>的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</li><li><strong>运输层运输层（transport layer）</strong><br>的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程</li><li><strong>网络层</strong><br>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</li><li><strong>数据链路层数据链路层（data link layer）</strong><br>通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</li><li><strong>物理层</strong><br>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题</title>
      <link href="/2019/10/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2019/10/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="第一题-‘1’-‘2’-‘3’-map-parseInt"><a href="#第一题-‘1’-‘2’-‘3’-map-parseInt" class="headerlink" title="第一题 : [‘1’, ‘2’, ‘3’].map(parseInt)"></a>第一题 : [‘1’, ‘2’, ‘3’].map(parseInt)</h2><p>第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。</p><ul><li><p>首先让我们回顾一下，<code>map</code>函数的第一个参数callback：<br><code>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])</code><br>这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p></li><li><p>而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。<br>parseInt(string, radix)<br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</p></li><li><p>了解这两个函数后，我们可以模拟一下运行情况</p></li></ul><ol><li>parseInt(‘1’, 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1</li><li>parseInt(‘2’, 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN</li><li>parseInt(‘3’, 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN<br>map函数返回的是一个数组，所以最后结果为<strong>[1, NaN, NaN]</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逐行解析Axios源码</title>
      <link href="/2019/10/27/axios/"/>
      <url>/2019/10/27/axios/</url>
      
        <content type="html"><![CDATA[<h2 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h2><p><a href="https://juejin.im/post/5d501512518825159e3d7be6" target="_blank" rel="noopener">转自掘金博主</a></p><pre><code># 📁 lib# |——  📁 adapters // axios主要使用的请求方法# |——  |——  📃 http.js  // axios中node端使用的请求函数# |——  |——  📃 xhr.js  // axios中浏览器端使用的请求函数# |——  📁 cancel# |——  |——  📃 Cancel.js // 定义了，取消请求返回的信息结构# |——  |——  📃 CancelToken.js // 定义了用于取消请求的主要方法# |——  |——  📃 isCancel.js // 判断是否是取消请求的信息# |——  📁 core# |——  |——  📃 Axios.js // Axios类# |——  |——  📃 dispatchRequest.js // 发起请求的地方 # |——  |——  📃 InterceptorManager.js // InterceptorManager类，拦截器类# |——  |——  📃 mergeConfig.js // 合并配置项# |——  |——  📃 settle.js // 根据请求状态，处理Promise# |——  |——  📃 createError.js // 生成指定的error# |——  |——  📃 enhanceError.js // 指定error对象的toJSON方法# |——  |——  📃 transformData.js // 使用default.js中transformRequest和transformResponse对响应以及请求进行格式化# |——  📁 helpers# |——  |——  📃 bind.js // 工具函数# |——  |——  📃 parseHeaders.js // 将getAllResponseHeaders返回的header信息转化为对象# |——  |——  📃 buildURL.js // 将params参数# |——  |——  📃 cookies.js // 封装了读取，写入，删除cookies的方法# |——  |——  📃 isURLSameOrigin.js // 检测当前的url与请求的url是否同源# |——  |——  📃 normalizeHeaderName.js // 对对象属性名的进行格式化，删除，新建符合大小写规范的属性# |——  |——  📃 combineURLs.js // 组合baseurl# |——  |——  📃 isAbsoluteURL.js // 判断是否为绝对路径（指的://或//开头的为绝对路径）# |——  📃 axios.js# |——  📃 defaults.js // axios中默认配置# |——  📃 utils.js // 一些工具方法# |——  |——  ⏹ isFormData // 判断是否是formData对象# |——  |——  ⏹ isStandardBrowserEnv // 判断当前环境是否为标准浏览器环境# |——  |——  ⏹ isUndefined // 判断是否为undefined# |——  |——  ⏹ merge# |——  |——  ⏹ isURLSearchParams // 判断是否为URLSearchParams对象</code></pre><h2 id="请求流程概览"><a href="#请求流程概览" class="headerlink" title="请求流程概览"></a>请求流程概览</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c708fba0d57810?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="源码逐行分析"><a href="#源码逐行分析" class="headerlink" title="源码逐行分析"></a>源码逐行分析</h2><h3 id="lib-cancel-CancelToken-js"><a href="#lib-cancel-CancelToken-js" class="headerlink" title="/lib/cancel/CancelToken.js"></a>/lib/cancel/CancelToken.js</h3><blockquote><p>CancelToken.js中定义了取消axios请求的相关行为的代码。但CancelToken.source返回的取消请求的cancel方法，使用的前提，是需要将CancelToken.source返回token的，结合到具体的请求的config中才能正常使用。</p></blockquote><h4 id="如何在axios中使用取消请求的功能？"><a href="#如何在axios中使用取消请求的功能？" class="headerlink" title="如何在axios中使用取消请求的功能？"></a>如何在axios中使用取消请求的功能？</h4><p>我在看axios源码之前，甚至并不知道axios可以发出的请求，所以我们先来了解下如何在axios取消一个请求。下面是一个例子🌰</p><pre><code>// axios用于取消请求的类const CancelToken = axios.CancelToken// source方法会返回一个对象，对象包含// {  // token, 添加到请求的config，用于标识请求  // cancel, 调用cancel方法取消请求// }const source = CancelToken.source()axios.get(&#39;/info&#39;, {  cancelToken: source.token}).catch(function(error) {  if (axios.isCancel(error)) {    console.log(&#39;取消请求的错误&#39;)  } else {    // 其他错误  }})// 调用source.cancel可以取消axios.get(&#39;/info&#39;)的请求source.cancel(&#39;取消请求&#39;)</code></pre><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code>var Cancel = require(&#39;./Cancel&#39;);function CancelToken(executor) {  if (typeof executor !== &#39;function&#39;) {    throw new TypeError(&#39;executor must be a function.&#39;);  }  var resolvePromise;  // 创建一个Promise  // 在调用cancel函数前该promise会一直处于pending状态  this.promise = new Promise(function promiseExecutor(resolve) {    resolvePromise = resolve;  });  var token = this;  executor(function cancel(message) {    // 判断是否已经取消请求了    if (token.reason) {      return;    }    // 创建取消请求的信息，并将信息添加到实例的reason属性上    token.reason = new Cancel(message);    // 结束this.promise的pending状态    // 将this.promise状态设置为resolve    resolvePromise(token.reason);  });}// 判断该请求是否已经被取消的方法CancelToken.prototype.throwIfRequested = function throwIfRequested() {  if (this.reason) {    throw this.reason;  }};CancelToken.source = function source() {  var cancel;  var token = new CancelToken(function executor(c) {    cancel = c;  });  return {    token: token,    cancel: cancel  };};module.exports = CancelToken;</code></pre><p>🤔 看到这里，我们还是无法了解axios是如何取消一个请求的。因为单独使用CancelToken.source返回的cancel是无法取消一个请求的，我们需要结合xhr.js中的代码来理解。</p><pre><code>// /lib/adapters/xhr.jsrequest.open()// ...省略// 如果配置了cancelToken选项if (config.cancelToken) {  // 对CancelToken中创建的Promise添加成功的回调  // 当调用CancelToken.source暴露的cancel函数时，回调会被触发  config.cancelToken.promise.then(function onCanceled(cancel) {    if (!request) {      return;    }    // 取消xhr请求    request.abort();    // 将axios返回的promise，置为reject态    reject(cancel);    request = null;  });}// ...省略request.send()</code></pre><p>想必大家看到这里，对axios中如何请求有了一个大致的了解。我们来总结一下，我们通过<strong>CancelToken，创建了一个额外的PromiseA，并将PromiseA挂载到config中，同时将该PromiseA的resolve方法暴露出去。我们在调用send方法前（发送请求前）添加对PromiseA的状态进行监听，当PromiseA的状态被修改，我们会在PromiseA的callback中取消请求，并且将axios返回的PromiseB的状态置为reject。从而达到取消请求的目的</strong>.</p><h3 id="lib-adapters-xhr-js"><a href="#lib-adapters-xhr-js" class="headerlink" title="/lib/adapters/xhr.js"></a>/lib/adapters/xhr.js</h3><blockquote><p>xhr.js导出的xhrAdapter方法是axios在浏览器环境下使用的默认请求方法。我们可以在配置中使用adapter配置项对默认请求方法进行替换。</p></blockquote><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><pre><code>module.exports = function xhrAdapter(config) {  return new Promise(function dispatchXhrRequest(resolve, reject) {    var requestData = config.data;    var requestHeaders = config.headers;    // 判断是否是FormData对象, 如果是, 删除header的Content-Type字段，让浏览器自动设置Content-Type字段    if (utils.isFormData(requestData)) {      delete requestHeaders[&#39;Content-Type&#39;];    }    // 创建xtr对象    var request = new XMLHttpRequest();    // 设置http请求头中的Authorization字段    // 关于Authorization字段    // 更多内容参考https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization    if (config.auth) {      var username = config.auth.username || &#39;&#39;;      var password = config.auth.password || &#39;&#39;;      // 使用btoa方法base64编码username和password      requestHeaders.Authorization = &#39;Basic &#39; + btoa(username + &#39;:&#39; + password);    }    // 初始化请求方法    // open(method: 请求的http方法, url: 请求的url地址, 是否支持异步)    request.open(      config.method.toUpperCase(),      buildURL(config.url, config.params, config.paramsSerializer),      true    );    // 设置超时时间    request.timeout = config.timeout;    // 监听readyState状态的变化，当readyState状态为4的时候，表示ajax请求成功    request.onreadystatechange = function handleLoad() {      if (!request || request.readyState !== 4) {        return;      }      // request.status响应的数字状态码，在完成请求前数字状态码等于0      // 如果request.status出错返回的也是0，但是file协议除外，status等于0也是一个成功的请求      // 更多内容请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status      if (request.status === 0 &amp;&amp; !(request.responseURL &amp;&amp; request.responseURL.indexOf(&#39;file:&#39;) === 0)) {        return;      }      // getAllResponseHeaders方法会返回所有的响应头      // 更多内容请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/getAllResponseHeaders      var responseHeaders = &#39;getAllResponseHeaders&#39; in request ? parseHeaders(request.getAllResponseHeaders()) : null;      // 如果没有设置数据响应类型（默认为“json”）或者responseType设置为text时，获取request.responseText值否则是获取request.response      // responseType是一个枚举类型，手动设置返回数据的类型 更多请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseType      // responseText是全部后端的返回数据为纯文本的值 更多请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/responseText      // response为正文，response的类型取决于responseType 更多请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/response      var responseData = !config.responseType || config.responseType === &#39;text&#39; ? request.responseText : request.response;      var response = {        data: responseData, // 响应正文        status: request.status, // 响应状态        statusText: request.statusText, // 响应状态的文本信息        headers: responseHeaders, // 响应头        config: config,        request: request      };      // status &gt;= 200 &amp;&amp; status &lt; 300 resolve      // 否则reject      settle(resolve, reject, response);      request = null;    };    // ajax中断时触发    request.onabort = function handleAbort() {      if (!request) {        return;      }      // 抛出Request aborted错误      reject(createError(&#39;Request aborted&#39;, config, &#39;ECONNABORTED&#39;, request));      request = null;    };    // ajax失败时触发    request.onerror = function handleError() {      // 抛出Network Error错误      reject(createError(&#39;Network Error&#39;, config, null, request));      request = null;    };    // ajax请求超时时调用    request.ontimeout = function handleTimeout() {      // 抛出 timeout错误      reject(createError(&#39;timeout of &#39; + config.timeout + &#39;ms exceeded&#39;, config, &#39;ECONNABORTED&#39;,        request));      request = null;    };    // 判断当前是为标准浏览器环境，如果是，添加xsrf头    // 什么是xsrf header？ xsrf header是用来防御CSRF攻击    // 原理是服务端生成一个XSRF-TOKEN，并保存到浏览器的cookie中，在每次请求中ajax都会将XSRF-TOKEN设置到request header中    // 服务器会比较cookie中的XSRF-TOKEN与header中XSRF-TOKEN是否一致    // 根据同源策略，非同源的网站无法读取修改本源的网站cookie，避免了伪造cookie    if (utils.isStandardBrowserEnv()) {      var cookies = require(&#39;./../helpers/cookies&#39;);      // withCredentials设置跨域请求中是否应该使用cookie 更多请参考 https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/withCredentials      // （设置了withCredentials为true或者是同源请求）并且设置xsrfCookieName      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) &amp;&amp; config.xsrfCookieName ?      // 读取cookie中XSRF-TOKEN        cookies.read(config.xsrfCookieName) :        undefined;      if (xsrfValue) {        // 在request header中设置XSRF-TOKEN        requestHeaders[config.xsrfHeaderName] = xsrfValue;      }    }    // setRequestHeader是用来设置请求头部的方法    if (&#39;setRequestHeader&#39; in request) {      // 将config中配置的requestHeaders，循环设置到请求头上      utils.forEach(requestHeaders, function setRequestHeader(val, key) {        if (typeof requestData === &#39;undefined&#39; &amp;&amp; key.toLowerCase() === &#39;content-type&#39;) {          delete requestHeaders[key];        } else {          request.setRequestHeader(key, val);        }      });    }    // 设置xhr对象的withCredentials属性，是否允许cookie进行跨域请求    if (config.withCredentials) {      request.withCredentials = true;    }    // 设置xhr对象的responseType属性    if (config.responseType) {      try {        request.responseType = config.responseType;      } catch (e) {        if (config.responseType !== &#39;json&#39;) {          throw e;        }      }    }    // 下载进度    if (typeof config.onDownloadProgress === &#39;function&#39;) {      request.addEventListener(&#39;progress&#39;, config.onDownloadProgress);    }    // 上传进度    // request.upload XMLHttpRequest.upload 属性返回一个 XMLHttpRequestUpload对象，用来表示上传的进度    if (typeof config.onUploadProgress === &#39;function&#39; &amp;&amp; request.upload) {      request.upload.addEventListener(&#39;progress&#39;, config.onUploadProgress);    }    if (config.cancelToken) {      // 取消请求，在介绍/lib/cancel/CancelToken.js中以及介绍，这里不在赘述      config.cancelToken.promise.then(function onCanceled(cancel) {        if (!request) {          return;        }        request.abort();        reject(cancel);        request = null;      });    }    if (requestData === undefined) {      requestData = null;    }    // 发送http请求    request.send(requestData);  });};</code></pre><h3 id="lib-core-dispatchRequest-js"><a href="#lib-core-dispatchRequest-js" class="headerlink" title="/lib/core/dispatchRequest.js"></a>/lib/core/dispatchRequest.js</h3><blockquote><p>dispatchRequest.js文件是axios源码中实际调用请求的地方。</p></blockquote><h4 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h4><pre><code>var utils = require(&#39;./../utils&#39;);var transformData = require(&#39;./transformData&#39;);var isCancel = require(&#39;../cancel/isCancel&#39;);var defaults = require(&#39;../defaults&#39;);var isAbsoluteURL = require(&#39;./../helpers/isAbsoluteURL&#39;);var combineURLs = require(&#39;./../helpers/combineURLs&#39;);// 判断请求是否已被取消，如果已经被取消，抛出已取消function throwIfCancellationRequested(config) {  if (config.cancelToken) {    config.cancelToken.throwIfRequested();  }}module.exports = function dispatchRequest(config) {  throwIfCancellationRequested(config);  // 如果包含baseUrl, 并且不是config.url绝对路径，组合baseUrl以及config.url  if (config.baseURL &amp;&amp; !isAbsoluteURL(config.url)) {    // 组合baseURL与url形成完整的请求路径    config.url = combineURLs(config.baseURL, config.url);  }  config.headers = config.headers || {};  // 使用/lib/defaults.js中的transformRequest方法，对config.headers和config.data进行格式化  // 比如将headers中的Accept，Content-Type统一处理成大写  // 比如如果请求正文是一个Object会格式化为JSON字符串，并添加application/json;charset=utf-8的Content-Type  // 等一系列操作  config.data = transformData(    config.data,    config.headers,    config.transformRequest  );  // 合并不同配置的headers，config.headers的配置优先级更高  config.headers = utils.merge(    config.headers.common || {},    config.headers[config.method] || {},    config.headers || {}  );  // 删除headers中的method属性  utils.forEach(    [&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;, &#39;post&#39;, &#39;put&#39;, &#39;patch&#39;, &#39;common&#39;],    function cleanHeaderConfig(method) {      delete config.headers[method];    }  );  // 如果config配置了adapter，使用config中配置adapter的替代默认的请求方法  var adapter = config.adapter || defaults.adapter;  // 使用adapter方法发起请求（adapter根据浏览器环境或者Node环境会有不同）  return adapter(config).then(    // 请求正确返回的回调    function onAdapterResolution(response) {      // 判断是否以及取消了请求，如果取消了请求抛出以取消      throwIfCancellationRequested(config);      // 使用/lib/defaults.js中的transformResponse方法，对服务器返回的数据进行格式化      // 例如，使用JSON.parse对响应正文进行解析      response.data = transformData(        response.data,        response.headers,        config.transformResponse      );      return response;    },    // 请求失败的回调    function onAdapterRejection(reason) {      if (!isCancel(reason)) {        throwIfCancellationRequested(config);        if (reason &amp;&amp; reason.response) {          reason.response.data = transformData(            reason.response.data,            reason.response.headers,            config.transformResponse          );        }      }      return Promise.reject(reason);    }  );};</code></pre><h3 id="lib-core-InterceptorManager-js"><a href="#lib-core-InterceptorManager-js" class="headerlink" title="/lib/core/InterceptorManager.js"></a>/lib/core/InterceptorManager.js</h3><blockquote><p>InterceptorManager.js文件中定义了axios拦截器类。包含了拦截器的添加，删除，循环拦截器。无论是响应拦截器还是请求拦截器，都是使用数组进行存储的。</p></blockquote><h4 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h4><pre><code>var utils = require(&#39;./../utils&#39;);// 拦截器类function InterceptorManager() {  // handlers数组用来存储拦截器  this.handlers = [];}// 添加拦截器，use方法接收两个参数，成功的回调以及失败的回调InterceptorManager.prototype.use = function use(fulfilled, rejected) {  this.handlers.push({    // 成功的回调    fulfilled: fulfilled,    // 失败的回调    rejected: rejected  });  return this.handlers.length - 1;};// 根据id(索引)，删除实例handlers属性中拦截器InterceptorManager.prototype.eject = function eject(id) {  if (this.handlers[id]) {    this.handlers[id] = null;  }};// 循环拦截器InterceptorManager.prototype.forEach = function forEach(fn) {  utils.forEach(this.handlers, function forEachHandler(h) {    if (h !== null) {      fn(h);    }  });};</code></pre><h3 id="lib-core-Axios-js"><a href="#lib-core-Axios-js" class="headerlink" title="/lib/core/Axios.js"></a>/lib/core/Axios.js</h3><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c708fba0e4e57d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><blockquote><p>Axios.js文件中定义了Axios实例上的request，get，post，delete方法。get，post，delete等方法均是基于Axios.prototype.request的封装📦。在Axios.prototype.request中会依次执行请求拦截器，dispatchRequest（实际发起），响应拦截器。整体的流程如👆上图所示。</p></blockquote><h4 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h4><pre><code>var utils = require(&#39;./../utils&#39;);var buildURL = require(&#39;../helpers/buildURL&#39;);var InterceptorManager = require(&#39;./InterceptorManager&#39;);var dispatchRequest = require(&#39;./dispatchRequest&#39;);var mergeConfig = require(&#39;./mergeConfig&#39;);function Axios(instanceConfig) {  // Axios的配置  this.defaults = instanceConfig;  // 拦截器  this.interceptors = {    request: new InterceptorManager(), // 请求拦截器    response: new InterceptorManager() // 响应拦截器  };}Axios.prototype.request = function request(config) {  // 如果config是一个字符串，把字符串当作请求的url地址  if (typeof config === &#39;string&#39;) {    config = arguments[1] || {};    config.url = arguments[0];  } else {    config = config || {};  }  // 合并配置  config = mergeConfig(this.defaults, config);  // 如果没有指定请求方法，使用get方法  config.method = config.method ? config.method.toLowerCase() : &#39;get&#39;;  var promise = Promise.resolve(config);  // 将请求拦截器，和响应拦截器，以及实际的请求（dispatchRequest）的方法组合成数组，类似如下的结构  // [请求拦截器1success, 请求拦截器1error, 请求拦截器2success, 请求拦截器2error, dispatchRequest, undefined, 响应拦截器1success, 响应拦截器1error]  var chain = [dispatchRequest, undefined];  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {    chain.unshift(interceptor.fulfilled, interceptor.rejected);  });  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {    chain.push(interceptor.fulfilled, interceptor.rejected);  });  // 开始执行整个请求流程（请求拦截器-&gt;dispatchRequest-&gt;响应拦截器）  // 流程可以理解为上图⬆️  while (chain.length) {    promise = promise.then(chain.shift(), chain.shift());  }  return promise;};Axios.prototype.getUri = function getUri(config) {  config = mergeConfig(this.defaults, config);  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, &#39;&#39;);};// 基于Axios.prototype.request封装其他方法// 将delete，get，head，options，post，put，patch添加到Axios.prototype的原型链上// Axios.prototype.delete =// Axios.prototype.get =// Axios.prototype.head =// Axios.prototype.options =// ...utils.forEach([&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;, &#39;options&#39;], function forEachMethodNoData(method) {  Axios.prototype[method] = function(url, config) {    return this.request(utils.merge(config || {}, {      method: method,      url: url    }));  };});utils.forEach([&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;], function forEachMethodWithData(method) {  Axios.prototype[method] = function(url, data, config) {    return this.request(utils.merge(config || {}, {      method: method,      url: url,      data: data    }));  };});module.exports = Axios;</code></pre><h3 id="lib-defaults-js"><a href="#lib-defaults-js" class="headerlink" title="/lib/defaults.js"></a>/lib/defaults.js</h3><blockquote><p>defaults.js文件中配置了，axios默认的请求头、不同的环境下axios默认使用的请求方法、格式化请求正文的方法，格式化响应正文方法等内容</p></blockquote><h4 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h4><pre><code>var utils = require(&#39;./utils&#39;);var normalizeHeaderName = require(&#39;./helpers/normalizeHeaderName&#39;);// 默认Content-Typevar DEFAULT_CONTENT_TYPE = {  &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;};// 设置ContentType，在没有设置的情况下function setContentTypeIfUnset(headers, value) {  if (!utils.isUndefined(headers) &amp;&amp; utils.isUndefined(headers[&#39;Content-Type&#39;])) {    headers[&#39;Content-Type&#39;] = value;  }}// 根据当前环境，获取默认的请求方法function getDefaultAdapter() {  var adapter;  // 判断当前环境是否存在process对象  if (typeof process !== &#39;undefined&#39; &amp;&amp; Object.prototype.toString.call(process) === &#39;[object process]&#39;) {    // node环境    adapter = require(&#39;./adapters/http&#39;);  } else if (typeof XMLHttpRequest !== &#39;undefined&#39;) {    // 浏览器环境    adapter = require(&#39;./adapters/xhr&#39;);  }  return adapter;}var defaults = {  // 默认的请求方法  adapter: getDefaultAdapter(),  // 格式化请求requestData，这会请求发送前使用  transformRequest: [    function transformRequest(data, headers) {      // 格式化header属性名，将header中不标准的属性名，格式化为Accept属性名      normalizeHeaderName(headers, &#39;Accept&#39;);      // 格式化header属性名，将header中不标准的属性名，格式化为Content-Type属性名      normalizeHeaderName(headers, &#39;Content-Type&#39;);      if (utils.isFormData(data) ||        utils.isArrayBuffer(data) ||        utils.isBuffer(data) ||        utils.isStream(data) ||        utils.isFile(data) ||        utils.isBlob(data)      ) {        return data;      }      if (utils.isArrayBufferView(data)) {        return data.buffer;      }      // URLSearchParams提供了一些用来处理URL查询字符串接口      // 如果是URLSearchParams对象      if (utils.isURLSearchParams(data)) {        // Content-Type设置为application/x-www-form-urlencoded        // application/x-www-form-urlencoded，数据被编码成以&amp;分隔的键值对        setContentTypeIfUnset(headers, &#39;application/x-www-form-urlencoded;charset=utf-8&#39;);        return data.toString();      }      // 如果是对象      if (utils.isObject(data)) {        // Content-Type设置为application/json        setContentTypeIfUnset(headers, &#39;application/json;charset=utf-8&#39;);        // 将请求正文格式化为JSON字符串，并返回        return JSON.stringify(data);      }      return data;    }  ],  // 格式化响应resposeData，这会响应接受后使用  transformResponse: [    function transformResponse(data) {      if (typeof data === &#39;string&#39;) {        try {          data = JSON.parse(data);        } catch (e) { /* Ignore */ }      }      return data;    }  ],  // 默认超时时间  timeout: 0,  // xsrf设置的cookie的key  xsrfCookieName: &#39;XSRF-TOKEN&#39;,  // xsrf设置header的key  xsrfHeaderName: &#39;X-XSRF-TOKEN&#39;,  maxContentLength: -1,  // 验证请求的状态  // 在处理请求的Promise会被使用  validateStatus: function validateStatus(status) {    return status &gt;= 200 &amp;&amp; status &lt; 300;  }};defaults.headers = {  // 通用的HTTP字段  // Accept告知客户端可以处理的类型  common: {    &#39;Accept&#39;: &#39;application/json, text/plain, */*&#39;  }};utils.forEach([&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;], function forEachMethodNoData(method) {  defaults.headers[method] = {};});// 为post，put，patch请求设置默认的Content-Typeutils.forEach([&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;], function forEachMethodWithData(method) {  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);});module.exports = defaults;</code></pre><h3 id="lib-axios-js"><a href="#lib-axios-js" class="headerlink" title="/lib/axios.js"></a>/lib/axios.js</h3><blockquote><p>axios.js文件是axios工具库的入口方法，在axios.js</p></blockquote><h4 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h4><pre><code>var utils = require(&#39;./utils&#39;);var bind = require(&#39;./helpers/bind&#39;);var Axios = require(&#39;./core/Axios&#39;);var mergeConfig = require(&#39;./core/mergeConfig&#39;);var defaults = require(&#39;./defaults&#39;);// 创建axios实例function createInstance(defaultConfig) {  var context = new Axios(defaultConfig);  // 更改Axios.prototype.request的this，执行context实例  // instance等于Axios.prototype.request方法  var instance = bind(Axios.prototype.request, context);  // 将Axios.prototype，context上的属性合并到instance  // instance.get = Axios.prototype.get  // instance.defaults = context.defaults  // ...  utils.extend(instance, Axios.prototype, context);   utils.extend(instance, context);  return instance;}// axios会直接对使用者暴露一个axios.request的方法，所以我们在使用axios的时候可以这样使用。不需要new一个axios的实例// import axios from &#39;axios&#39;// axios.get(&#39;/info&#39;)var axios = createInstance(defaults);axios.Axios = Axios;// axios.create可以根据用户自定义的config生成一个新的axios实例axios.create = function create(instanceConfig) {  return createInstance(mergeConfig(axios.defaults, instanceConfig));};axios.Cancel = require(&#39;./cancel/Cancel&#39;);axios.CancelToken = require(&#39;./cancel/CancelToken&#39;);axios.isCancel = require(&#39;./cancel/isCancel&#39;);axios.all = function all(promises) {  return Promise.all(promises);};axios.spread = require(&#39;./helpers/spread&#39;);module.exports = axios;module.exports.default = axios;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> axios </tag>
            
            <tag> 网络请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/2与HTTP/3 的新特性</title>
      <link href="/2019/10/25/http/"/>
      <url>/2019/10/25/http/</url>
      
        <content type="html"><![CDATA[<p>来自微信公众号前端工匠</p><h2 id="HTTP-1-1发明以来发生了哪些变化？"><a href="#HTTP-1-1发明以来发生了哪些变化？" class="headerlink" title="HTTP/1.1发明以来发生了哪些变化？"></a>HTTP/1.1发明以来发生了哪些变化？</h2><p>如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了<strong>2100K</strong>。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了<strong>100个</strong>。  </p><p>正如下图所示，从2011年以来,<strong>传输数据大小</strong>与<strong>平均请求资源数量</strong>不断持续增长，并没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1213d5962b05c?w=654&h=339&f=png&s=75559" alt></p><p><strong>HTTP/1.1</strong>自从1997年发布以来，我们已经使用HTTP/1.x 相当长一段时间了，但是随着近十年互联网的爆炸式发展，从当初网页内容以文本为主,到现在以富媒体（如图片、声音、视频）为主,而且对页面内容实时性高要求的应用越来越多(比如聊天、视频直播),于是当时协议规定的某些特性，已经无法满足现代网络的需求了。</p><h2 id="HTTP-1-1的缺陷"><a href="#HTTP-1-1的缺陷" class="headerlink" title="HTTP/1.1的缺陷"></a>HTTP/1.1的缺陷</h2><h3 id="高延迟–带来页面加载速度的降低"><a href="#高延迟–带来页面加载速度的降低" class="headerlink" title="高延迟–带来页面加载速度的降低"></a>高延迟–带来页面加载速度的降低</h3><p>虽然近几年来网络带宽增长非常快，然而我们却并没有看到<strong>网络延迟</strong>有对应程度的降低。网络延迟问题主要由于<strong>队头阻塞</strong>(Head-Of-Line Blocking),导致带宽无法被充分利用。   </p><p>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决: </p><ul><li><p>将同一页面的资源分散到不同域名下，提升连接上限。<strong>Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接</strong>，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。</p></li><li><p>Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。</p></li><li><p>内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</p></li><li><p>拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。</p></li></ul><h3 id="无状态特性–带来的巨大HTTP头部"><a href="#无状态特性–带来的巨大HTTP头部" class="headerlink" title="无状态特性–带来的巨大HTTP头部"></a>无状态特性–带来的巨大HTTP头部</h3><p>由于报文<code>Header</code>一般会携带”User Agent””Cookie””Accept””Server”等许多固定的头字段（如下图），多达几百字节甚至上千字节，但Body却经常只有几十字节（比如GET请求、 204/301/304响应），成了不折不扣的“大头儿子”。Header里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1213ef67b3850?w=729&h=253&f=png&s=121105" alt></p><h3 id="明文传输–带来的不安全性"><a href="#明文传输–带来的不安全性" class="headerlink" title="明文传输–带来的不安全性"></a>明文传输–带来的不安全性</h3><p>HTTP/1.1在传输数据时，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</p><p>你有没有听说过”免费WiFi陷阱”之类的新闻呢？黑客就是利用了HTTP明文传输的缺点，在公共场所架设一个WiFi热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个WiFi热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。</p><h3 id="不支持服务器推送消息"><a href="#不支持服务器推送消息" class="headerlink" title="不支持服务器推送消息"></a>不支持服务器推送消息</h3><h2 id="SPDY-协议与-HTTP-2-简介"><a href="#SPDY-协议与-HTTP-2-简介" class="headerlink" title="SPDY 协议与 HTTP/2 简介"></a>SPDY 协议与 HTTP/2 简介</h2><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>上面我们提到,由于HTTP/1.x的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到2009年，谷歌公开了自行研发的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12140c9cbb2aa?w=319&h=329&f=png&s=15867" alt><br><strong>HTTP/1.1有两个主要的缺点：安全不足和性能不高</strong>，由于背负着 HTTP/1.x 庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。如上图所示, SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承</p><h3 id="HTTP-2-简介"><a href="#HTTP-2-简介" class="headerlink" title="HTTP/2 简介"></a>HTTP/2 简介</h3><p>2015年，HTTP/2 发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。<strong>HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong>。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。</p><p>HTTP/2由两个规范（Specification）组成：</p><ul><li><p>Hypertext Transfer Protocol version 2 - RFC7540</p></li><li><p>HPACK - Header Compression for HTTP/2 - RFC7541</p></li></ul><h2 id="HTTP-2-新特性"><a href="#HTTP-2-新特性" class="headerlink" title="HTTP/2 新特性"></a>HTTP/2 新特性</h2><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p><strong>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</strong>。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong></p><p>它把TCP协议的部分特性挪到了应用层，把原来的”Header+Body”的消息”打散”为数个小片的二进制”帧”(Frame),用”HEADERS”帧存放头数据、”DATA”帧存放实体数据。HTP/2数据分帧后”Header+Body”的报文结构就完全消失了，协议看到的只是一个个的”碎片”。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12146311d2a9f?w=659&h=502&f=png&s=139914" alt><br>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。<strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</strong></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>HTTP/2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><p>具体来说:</p><ul><li><p>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；</p></li><li><p>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</p></li><li><p>每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值</p></li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12147db474b76?w=707&h=445&f=png&s=208421" alt></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。<br>大家可以通过 该链接 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1215b5b49b627?w=662&h=379&f=png&s=153256" alt><br>TTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,</p><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p></li></ul><p>这一特性，使性能有了极大提升：</p><ul><li><p>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。</p></li><li><p>并行交错地发送多个请求/响应，请求/响应之间互不影响。</p></li><li><p>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1214b0225bcc8?w=711&h=335&f=png&s=70021" alt><br>如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。</p></li></ul><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h3><p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）</p><p>例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1214d3468d2d6?w=697&h=299&f=png&s=106618" alt><br>另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h3 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h3><p>出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，<strong>所以“事实上”的HTTP/2是加密的。</strong>也就是说，互联网上通常所能见到的HTTP/2都是使用”https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2”表示加密的HTTP/2，“h2c”表示明文的HTTP/2。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12150cc0a5b80?w=629&h=308&f=png&s=100115" alt></p><h2 id="HTTP-3-新特性"><a href="#HTTP-3-新特性" class="headerlink" title="HTTP/3 新特性"></a>HTTP/3 新特性</h2><h3 id="HTTP-2-的缺点"><a href="#HTTP-2-的缺点" class="headerlink" title="HTTP/2 的缺点"></a>HTTP/2 的缺点</h3><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP/2的缺点主要有以下几点：</p><ul><li>TCP 以及 TCP+TLS建立连接的延时</li></ul><p>HTTP/2都是使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，<strong>这样就需要有两个握手延迟过程</strong>：</p><p>①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。</p><p>②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。</p><p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</p><ul><li>TCP的队头阻塞并没有彻底解决</li></ul><p>上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e121539aca15d3?w=704&h=254&f=png&s=50980" alt><br>读到这里，可能就会有人考虑为什么不直接去修改 TCP 协议？其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><h3 id="HTTP-3简介"><a href="#HTTP-3简介" class="headerlink" title="HTTP/3简介"></a>HTTP/3简介</h3><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1215a0f28a2ed?w=655&h=272&f=png&s=119742" alt><br>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。</p><h3 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h3><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p><ul><li>实现了类似TCP的流量控制、传输可靠性的功能。</li></ul><p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p><ul><li>实现了快速握手功能。</li></ul><p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</strong></p><ul><li>集成了TLS加密功能。</li></ul><p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p><ul><li>多路复用，彻底解决TCP中队头阻塞的问题</li></ul><p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e121571a06a492?w=699&h=227&f=png&s=63869" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</p></li><li><p>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</p></li><li><p>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p>透视HTTP协议</p></li><li><p>Web协议详解与抓包实战</p></li><li><p>浏览器工作原理与实践</p></li><li><p>HTTP2讲解</p></li><li><p>一文读懂 HTTP/2 特性</p></li><li><p>科普：QUIC协议原理分析</p></li><li><p>HTTP2简介和基于HTTP2的Web优化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2019/10/10/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/10/10/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数-原型-实例"><a href="#构造函数-原型-实例" class="headerlink" title="构造函数,原型,实例"></a>构造函数,原型,实例</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/18/16ca353635266a66?w=576&h=617&f=png&s=21273" alt><br>构造函数内部有一个名为<code>prototype</code> 的属性，通过这个属性就能访问到原型.</p><p><strong>Person</strong> 就是构造函数，<strong>Person.prototype</strong> 就是原型.</p><p>有个构造函数，我们就可以在原型上创建可以<strong>继承</strong>的属性，并通过 <code>new</code> 操作符创建实例.</p><p>实例通过 <code>__proto__</code> 访问到原型，所以如果是实例，那么就可以通过这个属性直接访问到原型.</p><p>既然构造函数通过 <code>prototype</code> 来访问到原型，那么原型也应该能够通过某种途径访问到构造函数，这就是 <code>constructor</code>.</p><p>原型同样也可以通过 <code>__proto__</code> 访问到原型的原型,，就会通过<code>__proto__</code>作为桥梁连接起来的一系列原型、原型的原型，直到尽头<code>null</code>为止。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情</p><ul><li><p>1、新生成了一个对象</p></li><li><p>2、链接到原型</p></li><li><p>3、绑定 this</p></li><li><p>4、返回新对象</p><pre><code>function create() {  // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === &#39;object&#39; ? result : obj}</code></pre><p>返回值可能由三种情况</p></li><li><p>1、返回一个对象 只能访问到返回对象中的属性。</p></li><li><p>2、没有 <code>return</code>，即返回 <code>undefined</code> 只能访问到构造函数中的属性</p></li><li><p>3、返回<code>undefined</code> 以外的基本类型 只能访问到构造函数中的属性<br>所以需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 obj对象。</p></li></ul><p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p><pre><code>function Foo() { return this;}Foo.getName = function () { console.log(&#39;1&#39;);};Foo.prototype.getName = function () { console.log(&#39;2&#39;);};new Foo.getName(); // -&gt; 1new Foo().getName(); // -&gt; 2 </code></pre><p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code>，所以对于上述代码来说可 以这样划分执行顺序</p><p><code>new (Foo.getName());</code></p><p><code>(new Foo()).getName();</code></p><p>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；对于后者来说， 先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 <code>Foo</code> 上的 <code>getName</code> 函数， 所以结果为 2。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 prototype。</p><p>我们也可以试着实现一下 instanceof</p><pre><code>function instanceof(left, right) {   // 获得类型的原型   let prototype = right.prototype   // 获得对象的原型   left = left.__proto__   // 判断对象的类型是否等于类型的原型   while (true) {       if (left === null)           return false       if (prototype === left)           return true       left = left.__proto__ //不存在沿着原型链继续找   }}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<br>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;}function SubType() {    this.subproperty = false;}// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototypeSubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() {    return this.subproperty;}var instance = new SubType();console.log(instance.getSuperValue()); // true</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0107fd80c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><pre><code>function SuperType(){  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot;</code></pre><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p><pre><code>function  SuperType(){    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];}function  SubType(){    //继承自SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.color.push(&quot;black&quot;);alert(instance1.color);//&quot;red,green,blue,black&quot;var instance2 = new SubType();alert(instance2.color);//&quot;red,green,blue&quot;</code></pre><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。<br>缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p><pre><code>function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};function SubType(name, age){  // 继承属性  // 第二次调用SuperType()  SuperType.call(this, name);  this.age = age;}// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){    alert(this.age);};var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c010c537ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name，color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p><pre><code>function object(obj){  function F(){}  F.prototype = obj;  return new F();}</code></pre><p><code>object()</code>对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</code></pre><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的<code>object</code>方法。</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><pre><code>function createAnother(original){  var clone = object(original); // 通过调用 object() 函数创建一个新对象  clone.sayHi = function(){  // 以某种方式来增强对象    alert(&quot;hi&quot;);  };  return clone; // 返回这个对象}</code></pre><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot;</code></pre><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p><pre><code>function inheritPrototype(subType, superType){  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型}// 父类初始化实例属性和原型属性function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age){  SuperType.call(this, name);  this.age = age;}// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function(){  alert(this.age);}var instance1 = new SubType(&quot;xyc&quot;, 23);var instance2 = new SubType(&quot;lxy&quot;, 23);instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0109df5438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code>上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code><br><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h3 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h3><pre><code>function MyClass() {     SuperClass.call(this);     OtherSuperClass.call(this);}// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() {     // do something};</code></pre><p><code>Object.assign</code>会把<code>OtherSuperClass</code>原型上的函数拷贝到<code>MyClass</code>原型上，使<code>MyClass</code>的所有实例都可用<code>OtherSuperClass</code>的方法。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><pre><code>class Rectangle {    // constructor    constructor(height, width) {        this.height = height;        this.width = width;    }    // Getter    get area() {        return this.calcArea()    }    // Method    calcArea() {        return this.height * this.width;    }}const rectangle = new Rectangle(10, 20);console.log(rectangle.area);// 输出 200-----------------------------------------------------------------// 继承class Square extends Rectangle {  constructor(length) {    super(length, length);    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。    this.name = &#39;Square&#39;;  }  get area() {    return this.height * this.width;  }}const square = new Square(10);console.log(square.area);// 输出 100</code></pre><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><pre><code>function _inherits(subType, superType) {    // 创建对象，创建父类原型的一个副本    // 增强对象，弥补因重写原型而失去的默认的constructor 属性    // 指定对象，将新创建的对象赋值给子类的原型    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {        constructor: {            value: subType,            enumerable: false,            writable: true,            configurable: true        }    });       if (superType) {        Object.setPrototypeOf             ? Object.setPrototypeOf(subType, superType)             : subType.__proto__ = superType;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="函数声明和类声明的区别"><a href="#函数声明和类声明的区别" class="headerlink" title="函数声明和类声明的区别"></a>函数声明和类声明的区别</h4><p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p><pre><code>let p = new Rectangle(); // ReferenceErrorclass Rectangle {}</code></pre><h4 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a>ES5继承和ES6继承的区别</h4><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 继承 </tag>
            
            <tag> new </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域</title>
      <link href="/2019/10/04/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/2019/10/04/%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 this 的值，也被称为 This Binding。</p><p>2、LexicalEnvironment（词法环境） 组件被创建。</p><p>3、VariableEnvironment（变量环境） 组件被创建。<br>直接看伪代码可能更加直观</p><p>ExecutionContext = {<br>  ThisBinding = <this value>,     // 确定this<br>  LexicalEnvironment = { … },   // 词法环境<br>  VariableEnvironment = { … },  // 变量环境<br>}<br>This Binding<br>全局执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window 对象，而在nodejs中指向这个文件的module对象。</this></p><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数，具体内容会在【this全面解析】部分详解。</p><p>词法环境（Lexical Environment）<br>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><p>变量环境<br>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li>1.变量提升<pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li>2.函数提升<pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。<br>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h3 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h3><h4 id="浏览器方法"><a href="#浏览器方法" class="headerlink" title="浏览器方法"></a>浏览器方法</h4><p>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</p><h4 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h4><p>使用 Node 提供的 process.memoryUsage 方法。</p><pre><code>console.log(process.memoryUsage());// 输出{   rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈  heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的  heapUsed: 3449392,    // 用到的堆的部分  external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre><p>判断内存泄漏，以heapUsed字段为准。</p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行栈 </tag>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2019/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种遵从<strong>先进后出 (LIFO)</strong> 原则的有序集合；新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端为栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。</p><pre><code>class Stack {    constructor() {        this.items = []    }    // 入栈    push(element) {         this.items.push(element)    }    // 出栈    pop() {        return this.items.pop()    }    // 末位    get peek() {        return this.items[this.items.length - 1]    }    // 是否为空栈    get isEmpty() {        return !this.items.length    }    // 尺寸    get size() {        return this.items.length    }    // 清空栈    clear() {        this.items = []    }    // 打印栈数据    print() {        console.log(this.items.toString())    }}</code></pre><p>使用栈类：</p><pre><code>// 实例化一个栈const stack = new Stack()console.log(stack.isEmpty) // true// 添加元素stack.push(5)stack.push(8)// 读取属性再添加console.log(stack.peek) // 8stack.push(11)console.log(stack.size) // 3console.log(stack.isEmpty) // false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用栈</title>
      <link href="/2019/09/28/%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2019/09/28/%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈<strong>LIFO</strong>规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中<strong>Pop</strong>出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 <code>this</code> 的值，也被称为 <strong>This Binding</strong>。</p><p>2、<strong>LexicalEnvironment（词法环境）</strong> 组件被创建。</p><p>3、<strong>VariableEnvironment（变量环境）</strong> 组件被创建。<br>直接看伪代码可能更加直观</p><pre><code>ExecutionContext = {    ThisBinding = &lt;this value&gt;,     // 确定this   LexicalEnvironment = { ... },   // 词法环境  VariableEnvironment = { ... },  // 变量环境}</code></pre><h3 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h3><p>全局执行上下文中，<code>this</code> 的值指向全局对象，在浏览器中<code>this</code> 的值指向 <code>window</code> 对象，而在nodejs中指向这个文件的<code>module</code>对象。</p><p>函数执行上下文中，<code>this</code> 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数.</p><h3 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h3><p>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><h3 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h3><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>1.变量提升</p><pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li><p>2.函数提升</p><pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><p><strong>内存回收</strong></p><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）<br><strong>内存泄漏识别方法</strong></p><ul><li>1、<strong>浏览器方法</strong><br>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li><li>2、<strong>命令行方法</strong><br>使用 Node 提供的 process.memoryUsage 方法。<pre><code>console.log(process.memoryUsage());// 输出{ rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的heapUsed: 3449392,    // 用到的堆的部分external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre>判断内存泄漏，以heapUsed字段为准。</li></ul><p><strong>WeakMap</strong></p><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
            <tag> 调用栈 </tag>
            
            <tag> 内存泄漏 </tag>
            
            <tag> 上下文 </tag>
            
            <tag> 垃圾回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2019/09/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/09/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</p><h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p>typeof 对于基本类型，除了 null 都可以显示正确的类型<br><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c6ee7529bae2d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>000 开头代表是对象，然而 null 表示 为全零，所以将它错误的判断为 object 。</p><h2 id="instanceof-和-Object-prototype-toString-call"><a href="#instanceof-和-Object-prototype-toString-call" class="headerlink" title="instanceof 和 Object.prototype.toString.call"></a>instanceof 和 Object.prototype.toString.call</h2><p>typeof 无法判断数组，对象.<br>可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[Object Type]</code> 的字符串。<br><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 <code>prototype</code>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="ToString负责处理非字符串到字符串的强制类型转换"><a href="#ToString负责处理非字符串到字符串的强制类型转换" class="headerlink" title="ToString负责处理非字符串到字符串的强制类型转换"></a><code>ToString</code>负责处理非字符串到字符串的强制类型转换</h3><p>null转换为’null’,undefined转换为’undefined’,其他基本类型都调用基本类型的包装对象属性toString()并返回值。</p><pre><code>const a = 123; const _a = new Number(123); console.log(String(a), _a.toString());               //&#39;123&#39; &#39;123&#39; 数字的字符串化遵循通用规则，但是极小极大数字使用指数形式const a = 1.07*1000*1000*1000*1000*1000*1000*1000;console.log(String(a));                               //&#39;1.07e+21&#39;</code></pre><p>对于普通对象来说，除非自行定义，否则<code>toString()</code>返回<code>Object.prototype.toString()</code>的值,其他对象有自己的<code>toString()</code>方法则调用自己的该方法.</p><pre><code>const b = {};console.log(String(b));                                //[object object]</code></pre><p>对于数组来说会转成以“，”拼接各项的字符串</p><pre><code>const arr = [{s:1},2,3]console.log(arr.toString())                           //&quot;[object Object],2,3&quot;</code></pre><h3 id="ToNumber负责处理非数字到数字的强制类型转换"><a href="#ToNumber负责处理非数字到数字的强制类型转换" class="headerlink" title="ToNumber负责处理非数字到数字的强制类型转换"></a><code>ToNumber</code>负责处理非数字到数字的强制类型转换</h3><p>true转换为1，false转换为0，undefined转换为NaN，null转换为0</p><pre><code>console.log(Number(null));                                //0 console.log(Number(undefined));                           //NaNconsole.log(Number(true));                                //1console.log(Number(false));                               //0</code></pre><p>对字符串的处理遵循数字常量的相关规定/语法，处理失败时返回NaN</p><pre><code>console.log(Number(&#39;123&#39;));                               //123console.log(Number(&#39;0b111&#39;));                             //7console.log(Number(&#39;0o123&#39;));                             //83console.log(Number(&#39;0x123&#39;));                             //291console.log(Number(&#39;123a&#39;));                              //NaNconsole.log(Number(&#39;a123&#39;));                              //NaN</code></pre><p>对象（包括数组）会首先按照<code>ToPrimitive</code>抽象操作被转换为相应的基本类型值，再按照前两条规则处理；如果某个对象即不存在<code>valueOf</code>方法也不存在<code>toString</code>方法，则会产生<code>TypeError</code>错误（例如Object.create(null)不存在以上两种方法）</p><pre><code>const arr = [1, 2, 3]; console.log(Number(arr));                               //NaNconsole.log(Number(arr.toString()));                    //NaNconst num = new Number(123);console.log(Number(num));                               //123console.log(Number(num.valueOf()));                     //123const bool = new Boolean(true);console.log(bool.valueOf());                           //trueconsole.log(Number(bool));                             //1console.log(Number(bool.valueOf()));                   //1const obj1 = {  toString:()=&gt;&quot;21&quot;}const obj2 = {  valueOf:()=&gt;&quot;42&quot;,  toString:()=&gt;&quot;21&quot;}const obj3 = {  a:1}console.log(Number(obj1));                              //21console.log(Number(obj2));                              //42console.log(obj3.toString());                           //[object Object]console.log(Number(obj3));                              //NaNconst obj = Object.create(null);console.log(Number(obj));                               //TypeError</code></pre><h3 id="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"><a href="#ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下" class="headerlink" title="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"></a><code>ToBoolean</code>负责处理非布尔值到布尔值的强制类型转换，规则如下</h3><p>可以被转换为<code>false</code>的值（<code>undefined</code>，<code>null</code>，<code>false</code>， <code>0</code>和<code>NaN</code>，’’）</p><p>其他都被转换为true（切记：封装对象均被转为true）</p><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换为字符串</p><p>一元运算符加号（+）首先把非基本类型通过ToPrimitive抽象操作转换为基本类型，如果加号中的两项有一项是字符串，另一项则进行ToString操作，进行字符串拼接，如果是布尔值加数字，则对布尔进行ToNumber操作再求和</p><p>隐式强制类型转换为数字，通过一元运算符-、/、*转换，遵循ToNumber的抽象值操作规则</p><p>隐式强制类型转换为布尔值</p><p>if(..)语句中的条件判断表达式</p><p>for(..;..;..)语句的第二个条件判断表达式</p><p>while(..)和do..while(..)的条件判断表达式</p><p>?:中的条件判断表达式</p><p>逻辑运算符||和&amp;&amp;左边的操作数（a||b等同于a?a:b，a&amp;&amp;b等同于a?b:a）</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
