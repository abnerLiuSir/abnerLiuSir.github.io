<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTTP/2与HTTP/3 的新特性</title>
      <link href="/2019/10/25/http/"/>
      <url>/2019/10/25/http/</url>
      
        <content type="html"><![CDATA[<p>来自微信公众号前端工匠</p><h2 id="HTTP-1-1发明以来发生了哪些变化？"><a href="#HTTP-1-1发明以来发生了哪些变化？" class="headerlink" title="HTTP/1.1发明以来发生了哪些变化？"></a>HTTP/1.1发明以来发生了哪些变化？</h2><p>如果仔细观察打开那些最流行的网站首页所需要下载的资源的话，会发现一个非常明显的趋势。近年来加载网站首页需要的下载的数据量在逐渐增加，并已经超过了<strong>2100K</strong>。但在这里我们更应该关心的是：平均每个页面为了完成显示与渲染所需要下载的资源数已经超过了<strong>100个</strong>。  </p><p>正如下图所示，从2011年以来,<strong>传输数据大小</strong>与<strong>平均请求资源数量</strong>不断持续增长，并没有减缓的迹象。该图表中绿色直线展示了传输数据大小的增长，红色直线展示了平均请求资源数量的增长。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1213d5962b05c?w=654&h=339&f=png&s=75559" alt></p><p><strong>HTTP/1.1</strong>自从1997年发布以来，我们已经使用HTTP/1.x 相当长一段时间了，但是随着近十年互联网的爆炸式发展，从当初网页内容以文本为主,到现在以富媒体（如图片、声音、视频）为主,而且对页面内容实时性高要求的应用越来越多(比如聊天、视频直播),于是当时协议规定的某些特性，已经无法满足现代网络的需求了。</p><h2 id="HTTP-1-1的缺陷"><a href="#HTTP-1-1的缺陷" class="headerlink" title="HTTP/1.1的缺陷"></a>HTTP/1.1的缺陷</h2><h3 id="高延迟–带来页面加载速度的降低"><a href="#高延迟–带来页面加载速度的降低" class="headerlink" title="高延迟–带来页面加载速度的降低"></a>高延迟–带来页面加载速度的降低</h3><p>虽然近几年来网络带宽增长非常快，然而我们却并没有看到<strong>网络延迟</strong>有对应程度的降低。网络延迟问题主要由于<strong>队头阻塞</strong>(Head-Of-Line Blocking),导致带宽无法被充分利用。   </p><p>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。针对队头阻塞,人们尝试过以下办法来解决: </p><ul><li><p>将同一页面的资源分散到不同域名下，提升连接上限。<strong>Chrome有个机制，对于同一个域名，默认允许同时建立 6 个 TCP持久连接</strong>，使用持久连接时，虽然能公用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。另外如果在同一个域名下同时有10个请求发生，那么其中4个请求会进入排队等待状态，直至进行中的请求完成。</p></li><li><p>Spriting合并多张小图为一张大图,再用JavaScript或者CSS将小图重新“切割”出来的技术。</p></li><li><p>内联(Inlining)是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</p></li><li><p>拼接(Concatenation)将多个体积较小的JavaScript使用webpack等工具打包成1个体积更大的JavaScript文件,但如果其中1个文件的改动就会导致大量数据被重新下载多个文件。</p></li></ul><h3 id="无状态特性–带来的巨大HTTP头部"><a href="#无状态特性–带来的巨大HTTP头部" class="headerlink" title="无状态特性–带来的巨大HTTP头部"></a>无状态特性–带来的巨大HTTP头部</h3><p>由于报文<code>Header</code>一般会携带”User Agent””Cookie””Accept””Server”等许多固定的头字段（如下图），多达几百字节甚至上千字节，但Body却经常只有几十字节（比如GET请求、 204/301/304响应），成了不折不扣的“大头儿子”。Header里携带的内容过大，在一定程度上增加了传输的成本。更要命的是，成千上万的请求响应报文里有很多字段值都是重复的，非常浪费。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1213ef67b3850?w=729&h=253&f=png&s=121105" alt></p><h3 id="明文传输–带来的不安全性"><a href="#明文传输–带来的不安全性" class="headerlink" title="明文传输–带来的不安全性"></a>明文传输–带来的不安全性</h3><p>HTTP/1.1在传输数据时，所有传输的内容都是<strong>明文</strong>，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。</p><p>你有没有听说过”免费WiFi陷阱”之类的新闻呢？黑客就是利用了HTTP明文传输的缺点，在公共场所架设一个WiFi热点开始“钓鱼”，诱骗网民上网。一旦你连上了这个WiFi热点，所有的流量都会被截获保存，里面如果有银行卡号、网站密码等敏感信息的话那就危险了，黑客拿到了这些数据就可以冒充你为所欲为。</p><h3 id="不支持服务器推送消息"><a href="#不支持服务器推送消息" class="headerlink" title="不支持服务器推送消息"></a>不支持服务器推送消息</h3><h2 id="SPDY-协议与-HTTP-2-简介"><a href="#SPDY-协议与-HTTP-2-简介" class="headerlink" title="SPDY 协议与 HTTP/2 简介"></a>SPDY 协议与 HTTP/2 简介</h2><h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>上面我们提到,由于HTTP/1.x的缺陷，我们会引入雪碧图、将小图内联、使用多个域名等等的方式来提高性能。不过这些优化都绕开了协议，直到2009年，谷歌公开了自行研发的 SPDY 协议，主要解决HTTP/1.1效率不高的问题。谷歌推出SPDY，才算是正式改造HTTP协议本身。降低延迟，压缩header等等，SPDY的实践证明了这些优化的效果，也最终带来HTTP/2的诞生。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12140c9cbb2aa?w=319&h=329&f=png&s=15867" alt><br><strong>HTTP/1.1有两个主要的缺点：安全不足和性能不高</strong>，由于背负着 HTTP/1.x 庞大的历史包袱,所以协议的修改,兼容性是首要考虑的目标，否则就会破坏互联网上无数现有的资产。如上图所示, SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。</p><p>SPDY 协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承</p><h3 id="HTTP-2-简介"><a href="#HTTP-2-简介" class="headerlink" title="HTTP/2 简介"></a>HTTP/2 简介</h3><p>2015年，HTTP/2 发布。HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写，HTTP方法/状态码/语义都与HTTP/1.x一样。<strong>HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong>。从目前的情况来看，国内外一些排名靠前的站点基本都实现了HTTP/2的部署，使用HTTP/2能带来20%~60%的效率提升。</p><p>HTTP/2由两个规范（Specification）组成：</p><ul><li><p>Hypertext Transfer Protocol version 2 - RFC7540</p></li><li><p>HPACK - Header Compression for HTTP/2 - RFC7541</p></li></ul><h2 id="HTTP-2-新特性"><a href="#HTTP-2-新特性" class="headerlink" title="HTTP/2 新特性"></a>HTTP/2 新特性</h2><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p><strong>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</strong>。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<strong>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</strong></p><p>它把TCP协议的部分特性挪到了应用层，把原来的”Header+Body”的消息”打散”为数个小片的二进制”帧”(Frame),用”HEADERS”帧存放头数据、”DATA”帧存放实体数据。HTP/2数据分帧后”Header+Body”的报文结构就完全消失了，协议看到的只是一个个的”碎片”。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12146311d2a9f?w=659&h=502&f=png&s=139914" alt><br>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。<strong>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。</strong></p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>HTTP/2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><p>具体来说:</p><ul><li><p>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；</p></li><li><p>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</p></li><li><p>每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值</p></li></ul><p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12147db474b76?w=707&h=445&f=png&s=208421" alt></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。<br>大家可以通过 该链接 直观感受下 HTTP/2 比 HTTP/1 到底快了多少。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1215b5b49b627?w=662&h=379&f=png&s=153256" alt><br>TTP/2 中，有了二进制分帧之后，HTTP /2 不再依赖 TCP 链接去实现多流并行了，在 HTTP/2中,</p><ul><li><p>同域名下所有通信都在单个连接上完成。</p></li><li><p>单个连接可以承载任意数量的双向数据流。</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p></li></ul><p>这一特性，使性能有了极大提升：</p><ul><li><p>同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。</p></li><li><p>并行交错地发送多个请求/响应，请求/响应之间互不影响。</p></li><li><p>在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1214b0225bcc8?w=711&h=335&f=png&s=70021" alt><br>如上图所示，多路复用的技术可以只通过一个 TCP 连接就可以传输所有的请求数据。</p></li></ul><h3 id="Server-Push"><a href="#Server-Push" class="headerlink" title="Server Push"></a>Server Push</h3><p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为”服务器推送”（ Server Push，也叫 Cache push）</p><p>例如下图所示,服务端主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1214d3468d2d6?w=697&h=299&f=png&s=106618" alt><br>另外需要补充的是,服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方确认才行。</p><h3 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h3><p>出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p><p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，<strong>所以“事实上”的HTTP/2是加密的。</strong>也就是说，互联网上通常所能见到的HTTP/2都是使用”https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2”表示加密的HTTP/2，“h2c”表示明文的HTTP/2。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e12150cc0a5b80?w=629&h=308&f=png&s=100115" alt></p><h2 id="HTTP-3-新特性"><a href="#HTTP-3-新特性" class="headerlink" title="HTTP/3 新特性"></a>HTTP/3 新特性</h2><h3 id="HTTP-2-的缺点"><a href="#HTTP-2-的缺点" class="headerlink" title="HTTP/2 的缺点"></a>HTTP/2 的缺点</h3><p>虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP/2的缺点主要有以下几点：</p><ul><li>TCP 以及 TCP+TLS建立连接的延时</li></ul><p>HTTP/2都是使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程，<strong>这样就需要有两个握手延迟过程</strong>：</p><p>①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。</p><p>②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。</p><p>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</p><ul><li>TCP的队头阻塞并没有彻底解决</li></ul><p>上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e121539aca15d3?w=704&h=254&f=png&s=50980" alt><br>读到这里，可能就会有人考虑为什么不直接去修改 TCP 协议？其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</p><h3 id="HTTP-3简介"><a href="#HTTP-3简介" class="headerlink" title="HTTP/3简介"></a>HTTP/3简介</h3><p>Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e1215a0f28a2ed?w=655&h=272&f=png&s=119742" alt><br>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。</p><h3 id="QUIC新功能"><a href="#QUIC新功能" class="headerlink" title="QUIC新功能"></a>QUIC新功能</h3><p>上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p><ul><li>实现了类似TCP的流量控制、传输可靠性的功能。</li></ul><p>虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p><ul><li>实现了快速握手功能。</li></ul><p>由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</strong></p><ul><li>集成了TLS加密功能。</li></ul><p>目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。</p><ul><li>多路复用，彻底解决TCP中队头阻塞的问题</li></ul><p>和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。<br><img src="https://user-gold-cdn.xitu.io/2019/10/28/16e121571a06a492?w=699&h=227&f=png&s=63869" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</p></li><li><p>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS”，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</p></li><li><p>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p>透视HTTP协议</p></li><li><p>Web协议详解与抓包实战</p></li><li><p>浏览器工作原理与实践</p></li><li><p>HTTP2讲解</p></li><li><p>一文读懂 HTTP/2 特性</p></li><li><p>科普：QUIC协议原理分析</p></li><li><p>HTTP2简介和基于HTTP2的Web优化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链</title>
      <link href="/2018/10/10/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/10/10/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数-原型-实例"><a href="#构造函数-原型-实例" class="headerlink" title="构造函数,原型,实例"></a>构造函数,原型,实例</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/18/16ca353635266a66?w=576&h=617&f=png&s=21273" alt><br>构造函数内部有一个名为<code>prototype</code> 的属性，通过这个属性就能访问到原型.</p><p><strong>Person</strong> 就是构造函数，<strong>Person.prototype</strong> 就是原型.</p><p>有个构造函数，我们就可以在原型上创建可以<strong>继承</strong>的属性，并通过 <code>new</code> 操作符创建实例.</p><p>实例通过 <code>__proto__</code> 访问到原型，所以如果是实例，那么就可以通过这个属性直接访问到原型.</p><p>既然构造函数通过 <code>prototype</code> 来访问到原型，那么原型也应该能够通过某种途径访问到构造函数，这就是 <code>constructor</code>.</p><p>原型同样也可以通过 <code>__proto__</code> 访问到原型的原型,，就会通过<code>__proto__</code>作为桥梁连接起来的一系列原型、原型的原型，直到尽头<code>null</code>为止。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情</p><ul><li><p>1、新生成了一个对象</p></li><li><p>2、链接到原型</p></li><li><p>3、绑定 this</p></li><li><p>4、返回新对象</p><pre><code>function create() {  // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === &#39;object&#39; ? result : obj}</code></pre><p>返回值可能由三种情况</p></li><li><p>1、返回一个对象 只能访问到返回对象中的属性。</p></li><li><p>2、没有 <code>return</code>，即返回 <code>undefined</code> 只能访问到构造函数中的属性</p></li><li><p>3、返回<code>undefined</code> 以外的基本类型 只能访问到构造函数中的属性<br>所以需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 obj对象。</p></li></ul><p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p><pre><code>function Foo() { return this;}Foo.getName = function () { console.log(&#39;1&#39;);};Foo.prototype.getName = function () { console.log(&#39;2&#39;);};new Foo.getName(); // -&gt; 1new Foo().getName(); // -&gt; 2 </code></pre><p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code>，所以对于上述代码来说可 以这样划分执行顺序</p><p><code>new (Foo.getName());</code></p><p><code>(new Foo()).getName();</code></p><p>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；对于后者来说， 先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 <code>Foo</code> 上的 <code>getName</code> 函数， 所以结果为 2。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 prototype。</p><p>我们也可以试着实现一下 instanceof</p><pre><code>function instanceof(left, right) {   // 获得类型的原型   let prototype = right.prototype   // 获得对象的原型   left = left.__proto__   // 判断对象的类型是否等于类型的原型   while (true) {       if (left === null)           return false       if (prototype === left)           return true       left = left.__proto__ //不存在沿着原型链继续找   }}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<br>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;}function SubType() {    this.subproperty = false;}// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototypeSubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() {    return this.subproperty;}var instance = new SubType();console.log(instance.getSuperValue()); // true</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0107fd80c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><pre><code>function SuperType(){  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot;</code></pre><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p><pre><code>function  SuperType(){    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];}function  SubType(){    //继承自SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.color.push(&quot;black&quot;);alert(instance1.color);//&quot;red,green,blue,black&quot;var instance2 = new SubType();alert(instance2.color);//&quot;red,green,blue&quot;</code></pre><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。<br>缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p><pre><code>function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};function SubType(name, age){  // 继承属性  // 第二次调用SuperType()  SuperType.call(this, name);  this.age = age;}// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){    alert(this.age);};var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c010c537ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name，color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p><pre><code>function object(obj){  function F(){}  F.prototype = obj;  return new F();}</code></pre><p><code>object()</code>对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</code></pre><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的<code>object</code>方法。</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><pre><code>function createAnother(original){  var clone = object(original); // 通过调用 object() 函数创建一个新对象  clone.sayHi = function(){  // 以某种方式来增强对象    alert(&quot;hi&quot;);  };  return clone; // 返回这个对象}</code></pre><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot;</code></pre><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p><pre><code>function inheritPrototype(subType, superType){  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型}// 父类初始化实例属性和原型属性function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age){  SuperType.call(this, name);  this.age = age;}// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function(){  alert(this.age);}var instance1 = new SubType(&quot;xyc&quot;, 23);var instance2 = new SubType(&quot;lxy&quot;, 23);instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0109df5438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code>上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code><br><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h3 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h3><pre><code>function MyClass() {     SuperClass.call(this);     OtherSuperClass.call(this);}// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() {     // do something};</code></pre><p><code>Object.assign</code>会把<code>OtherSuperClass</code>原型上的函数拷贝到<code>MyClass</code>原型上，使<code>MyClass</code>的所有实例都可用<code>OtherSuperClass</code>的方法。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><pre><code>class Rectangle {    // constructor    constructor(height, width) {        this.height = height;        this.width = width;    }    // Getter    get area() {        return this.calcArea()    }    // Method    calcArea() {        return this.height * this.width;    }}const rectangle = new Rectangle(10, 20);console.log(rectangle.area);// 输出 200-----------------------------------------------------------------// 继承class Square extends Rectangle {  constructor(length) {    super(length, length);    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。    this.name = &#39;Square&#39;;  }  get area() {    return this.height * this.width;  }}const square = new Square(10);console.log(square.area);// 输出 100</code></pre><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><pre><code>function _inherits(subType, superType) {    // 创建对象，创建父类原型的一个副本    // 增强对象，弥补因重写原型而失去的默认的constructor 属性    // 指定对象，将新创建的对象赋值给子类的原型    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {        constructor: {            value: subType,            enumerable: false,            writable: true,            configurable: true        }    });       if (superType) {        Object.setPrototypeOf             ? Object.setPrototypeOf(subType, superType)             : subType.__proto__ = superType;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="函数声明和类声明的区别"><a href="#函数声明和类声明的区别" class="headerlink" title="函数声明和类声明的区别"></a>函数声明和类声明的区别</h4><p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p><pre><code>let p = new Rectangle(); // ReferenceErrorclass Rectangle {}</code></pre><h4 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a>ES5继承和ES6继承的区别</h4><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 继承 </tag>
            
            <tag> new </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域</title>
      <link href="/2018/10/04/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/2018/10/04/%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 this 的值，也被称为 This Binding。</p><p>2、LexicalEnvironment（词法环境） 组件被创建。</p><p>3、VariableEnvironment（变量环境） 组件被创建。<br>直接看伪代码可能更加直观</p><p>ExecutionContext = {<br>  ThisBinding = <this value>,     // 确定this<br>  LexicalEnvironment = { … },   // 词法环境<br>  VariableEnvironment = { … },  // 变量环境<br>}<br>This Binding<br>全局执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window 对象，而在nodejs中指向这个文件的module对象。</this></p><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数，具体内容会在【this全面解析】部分详解。</p><p>词法环境（Lexical Environment）<br>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><p>变量环境<br>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li>1.变量提升<pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li>2.函数提升<pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。<br>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h3 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h3><h4 id="浏览器方法"><a href="#浏览器方法" class="headerlink" title="浏览器方法"></a>浏览器方法</h4><p>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</p><h4 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h4><p>使用 Node 提供的 process.memoryUsage 方法。</p><pre><code>console.log(process.memoryUsage());// 输出{   rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈  heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的  heapUsed: 3449392,    // 用到的堆的部分  external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre><p>判断内存泄漏，以heapUsed字段为准。</p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行栈 </tag>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用栈</title>
      <link href="/2018/09/28/%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2018/09/28/%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈<strong>LIFO</strong>规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中<strong>Pop</strong>出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 <code>this</code> 的值，也被称为 <strong>This Binding</strong>。</p><p>2、<strong>LexicalEnvironment（词法环境）</strong> 组件被创建。</p><p>3、<strong>VariableEnvironment（变量环境）</strong> 组件被创建。<br>直接看伪代码可能更加直观</p><pre><code>ExecutionContext = {    ThisBinding = &lt;this value&gt;,     // 确定this   LexicalEnvironment = { ... },   // 词法环境  VariableEnvironment = { ... },  // 变量环境}</code></pre><h3 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h3><p>全局执行上下文中，<code>this</code> 的值指向全局对象，在浏览器中<code>this</code> 的值指向 <code>window</code> 对象，而在nodejs中指向这个文件的<code>module</code>对象。</p><p>函数执行上下文中，<code>this</code> 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数.</p><h3 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h3><p>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><h3 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h3><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>1.变量提升</p><pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li><p>2.函数提升</p><pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><p><strong>内存回收</strong></p><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）<br><strong>内存泄漏识别方法</strong></p><ul><li>1、<strong>浏览器方法</strong><br>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li><li>2、<strong>命令行方法</strong><br>使用 Node 提供的 process.memoryUsage 方法。<pre><code>console.log(process.memoryUsage());// 输出{ rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的heapUsed: 3449392,    // 用到的堆的部分external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre>判断内存泄漏，以heapUsed字段为准。</li></ul><p><strong>WeakMap</strong></p><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
            <tag> 调用栈 </tag>
            
            <tag> 内存泄漏 </tag>
            
            <tag> 上下文 </tag>
            
            <tag> 垃圾回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2018/09/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/20/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</p><h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p>typeof 对于基本类型，除了 null 都可以显示正确的类型<br><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c6ee7529bae2d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>000 开头代表是对象，然而 null 表示 为全零，所以将它错误的判断为 object 。</p><h2 id="instanceof-和-Object-prototype-toString-call"><a href="#instanceof-和-Object-prototype-toString-call" class="headerlink" title="instanceof 和 Object.prototype.toString.call"></a>instanceof 和 Object.prototype.toString.call</h2><p>typeof 无法判断数组，对象.<br>可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[Object Type]</code> 的字符串。<br><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 <code>prototype</code>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="ToString负责处理非字符串到字符串的强制类型转换"><a href="#ToString负责处理非字符串到字符串的强制类型转换" class="headerlink" title="ToString负责处理非字符串到字符串的强制类型转换"></a><code>ToString</code>负责处理非字符串到字符串的强制类型转换</h3><p>null转换为’null’,undefined转换为’undefined’,其他基本类型都调用基本类型的包装对象属性toString()并返回值。</p><pre><code>const a = 123; const _a = new Number(123); console.log(String(a), _a.toString());               //&#39;123&#39; &#39;123&#39; 数字的字符串化遵循通用规则，但是极小极大数字使用指数形式const a = 1.07*1000*1000*1000*1000*1000*1000*1000;console.log(String(a));                               //&#39;1.07e+21&#39;</code></pre><p>对于普通对象来说，除非自行定义，否则<code>toString()</code>返回<code>Object.prototype.toString()</code>的值,其他对象有自己的<code>toString()</code>方法则调用自己的该方法.</p><pre><code>const b = {};console.log(String(b));                                //[object object]</code></pre><p>对于数组来说会转成以“，”拼接各项的字符串</p><pre><code>const arr = [{s:1},2,3]console.log(arr.toString())                           //&quot;[object Object],2,3&quot;</code></pre><h3 id="ToNumber负责处理非数字到数字的强制类型转换"><a href="#ToNumber负责处理非数字到数字的强制类型转换" class="headerlink" title="ToNumber负责处理非数字到数字的强制类型转换"></a><code>ToNumber</code>负责处理非数字到数字的强制类型转换</h3><p>true转换为1，false转换为0，undefined转换为NaN，null转换为0</p><pre><code>console.log(Number(null));                                //0 console.log(Number(undefined));                           //NaNconsole.log(Number(true));                                //1console.log(Number(false));                               //0</code></pre><p>对字符串的处理遵循数字常量的相关规定/语法，处理失败时返回NaN</p><pre><code>console.log(Number(&#39;123&#39;));                               //123console.log(Number(&#39;0b111&#39;));                             //7console.log(Number(&#39;0o123&#39;));                             //83console.log(Number(&#39;0x123&#39;));                             //291console.log(Number(&#39;123a&#39;));                              //NaNconsole.log(Number(&#39;a123&#39;));                              //NaN</code></pre><p>对象（包括数组）会首先按照<code>ToPrimitive</code>抽象操作被转换为相应的基本类型值，再按照前两条规则处理；如果某个对象即不存在<code>valueOf</code>方法也不存在<code>toString</code>方法，则会产生<code>TypeError</code>错误（例如Object.create(null)不存在以上两种方法）</p><pre><code>const arr = [1, 2, 3]; console.log(Number(arr));                               //NaNconsole.log(Number(arr.toString()));                    //NaNconst num = new Number(123);console.log(Number(num));                               //123console.log(Number(num.valueOf()));                     //123const bool = new Boolean(true);console.log(bool.valueOf());                           //trueconsole.log(Number(bool));                             //1console.log(Number(bool.valueOf()));                   //1const obj1 = {  toString:()=&gt;&quot;21&quot;}const obj2 = {  valueOf:()=&gt;&quot;42&quot;,  toString:()=&gt;&quot;21&quot;}const obj3 = {  a:1}console.log(Number(obj1));                              //21console.log(Number(obj2));                              //42console.log(obj3.toString());                           //[object Object]console.log(Number(obj3));                              //NaNconst obj = Object.create(null);console.log(Number(obj));                               //TypeError</code></pre><h3 id="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"><a href="#ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下" class="headerlink" title="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"></a><code>ToBoolean</code>负责处理非布尔值到布尔值的强制类型转换，规则如下</h3><p>可以被转换为<code>false</code>的值（<code>undefined</code>，<code>null</code>，<code>false</code>， <code>0</code>和<code>NaN</code>，’’）</p><p>其他都被转换为true（切记：封装对象均被转为true）</p><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换为字符串</p><p>一元运算符加号（+）首先把非基本类型通过ToPrimitive抽象操作转换为基本类型，如果加号中的两项有一项是字符串，另一项则进行ToString操作，进行字符串拼接，如果是布尔值加数字，则对布尔进行ToNumber操作再求和</p><p>隐式强制类型转换为数字，通过一元运算符-、/、*转换，遵循ToNumber的抽象值操作规则</p><p>隐式强制类型转换为布尔值</p><p>if(..)语句中的条件判断表达式</p><p>for(..;..;..)语句的第二个条件判断表达式</p><p>while(..)和do..while(..)的条件判断表达式</p><p>?:中的条件判断表达式</p><p>逻辑运算符||和&amp;&amp;左边的操作数（a||b等同于a?a:b，a&amp;&amp;b等同于a?b:a）</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
