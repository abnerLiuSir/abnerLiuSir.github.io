<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>原型链</title>
      <link href="/2018/09/07/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/09/07/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="构造函数-原型-实例"><a href="#构造函数-原型-实例" class="headerlink" title="构造函数,原型,实例"></a>构造函数,原型,实例</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/18/16ca353635266a66?w=576&h=617&f=png&s=21273" alt><br>构造函数内部有一个名为<code>prototype</code> 的属性，通过这个属性就能访问到原型.</p><p><strong>Person</strong> 就是构造函数，<strong>Person.prototype</strong> 就是原型.</p><p>有个构造函数，我们就可以在原型上创建可以<strong>继承</strong>的属性，并通过 <code>new</code> 操作符创建实例.</p><p>实例通过 <code>__proto__</code> 访问到原型，所以如果是实例，那么就可以通过这个属性直接访问到原型.</p><p>既然构造函数通过 <code>prototype</code> 来访问到原型，那么原型也应该能够通过某种途径访问到构造函数，这就是 <code>constructor</code>.</p><p>原型同样也可以通过 <code>__proto__</code> 访问到原型的原型,，就会通过<code>__proto__</code>作为桥梁连接起来的一系列原型、原型的原型，直到尽头<code>null</code>为止。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p><p>当代码 <code>new Foo(...)</code> 执行时，会发生以下事情</p><ul><li><p>1、新生成了一个对象</p></li><li><p>2、链接到原型</p></li><li><p>3、绑定 this</p></li><li><p>4、返回新对象</p><pre><code>function create() {  // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === &#39;object&#39; ? result : obj}</code></pre><p>返回值可能由三种情况</p></li><li><p>1、返回一个对象 只能访问到返回对象中的属性。</p></li><li><p>2、没有 <code>return</code>，即返回 <code>undefined</code> 只能访问到构造函数中的属性</p></li><li><p>3、返回<code>undefined</code> 以外的基本类型 只能访问到构造函数中的属性<br>所以需要判断下返回的值是不是一个对象，如果是对象则返回这个对象，不然返回新创建的 obj对象。</p></li></ul><p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p><pre><code>function Foo() { return this;}Foo.getName = function () { console.log(&#39;1&#39;);};Foo.prototype.getName = function () { console.log(&#39;2&#39;);};new Foo.getName(); // -&gt; 1new Foo().getName(); // -&gt; 2 </code></pre><p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code>，所以对于上述代码来说可 以这样划分执行顺序</p><p><code>new (Foo.getName());</code></p><p><code>(new Foo()).getName();</code></p><p>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；对于后者来说， 先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 <code>Foo</code> 上的 <code>getName</code> 函数， 所以结果为 2。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 prototype。</p><p>我们也可以试着实现一下 instanceof</p><pre><code>function instanceof(left, right) {   // 获得类型的原型   let prototype = right.prototype   // 获得对象的原型   left = left.__proto__   // 判断对象的类型是否等于类型的原型   while (true) {       if (left === null)           return false       if (prototype === left)           return true       left = left.__proto__ //不存在沿着原型链继续找   }}</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。<br>继承的本质就是<strong>复制，即重写原型对象，代之以一个新类型的实例</strong>。</p><pre><code>function SuperType() {    this.property = true;}SuperType.prototype.getSuperValue = function() {    return this.property;}function SubType() {    this.subproperty = false;}// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototypeSubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() {    return this.subproperty;}var instance = new SubType();console.log(instance.getSuperValue()); // true</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0107fd80c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。</p><pre><code>function SuperType(){  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}function SubType(){}SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType(); alert(instance2.colors); //&quot;red,blue,green,black&quot;</code></pre><h3 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h3><p>使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）</p><pre><code>function  SuperType(){    this.color=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];}function  SubType(){    //继承自SuperType    SuperType.call(this);}var instance1 = new SubType();instance1.color.push(&quot;black&quot;);alert(instance1.color);//&quot;red,green,blue,black&quot;var instance2 = new SubType();alert(instance2.color);//&quot;red,green,blue&quot;</code></pre><p>核心代码是<code>SuperType.call(this)</code>，创建子类实例时调用<code>SuperType</code>构造函数，于是<code>SubType</code>的每个实例都会将<code>SuperType</code>中的属性复制一份。<br>缺点：</p><ul><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合上述两种方法就是组合继承。用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承。</p><pre><code>function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};function SubType(name, age){  // 继承属性  // 第二次调用SuperType()  SuperType.call(this, name);  this.age = age;}// 继承方法// 构建原型链// 第一次调用SuperType()SubType.prototype = new SuperType(); // 重写SubType.prototype的constructor属性，指向自己的构造函数SubTypeSubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){    alert(this.age);};var instance1 = new SubType(&quot;Nicholas&quot;, 29);instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName(); //&quot;Nicholas&quot;;instance1.sayAge(); //29var instance2 = new SubType(&quot;Greg&quot;, 27);alert(instance2.colors); //&quot;red,blue,green&quot;instance2.sayName(); //&quot;Greg&quot;;instance2.sayAge(); //27</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c010c537ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>缺点：</p><ul><li>第一次调用<code>SuperType()</code>：给<code>SubType.prototype</code>写入两个属性<code>name</code>，<code>color</code>。</li><li>第二次调用<code>SuperType()</code>：给<code>instance1</code>写入两个属性<code>name，color</code>。</li></ul><p>实例对象<code>instance1</code>上的两个属性就屏蔽了其原型对象<code>SubType.prototype</code>的两个同名属性。所以，组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。</p><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</p><pre><code>function object(obj){  function F(){}  F.prototype = obj;  return new F();}</code></pre><p><code>object()</code>对传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象。</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = object(person);anotherPerson.name = &quot;Greg&quot;;anotherPerson.friends.push(&quot;Rob&quot;);var yetAnotherPerson = object(person);yetAnotherPerson.name = &quot;Linda&quot;;yetAnotherPerson.friends.push(&quot;Barbie&quot;);alert(person.friends);   //&quot;Shelby,Court,Van,Rob,Barbie&quot;</code></pre><p>缺点：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数<br>另外，ES5中存在<code>Object.create()</code>的方法，能够代替上面的<code>object</code>方法。</li></ul><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>核心：在原型式继承的基础上，增强对象，返回构造函数</p><pre><code>function createAnother(original){  var clone = object(original); // 通过调用 object() 函数创建一个新对象  clone.sayHi = function(){  // 以某种方式来增强对象    alert(&quot;hi&quot;);  };  return clone; // 返回这个对象}</code></pre><p>函数的主要作用是为构造函数新增属性和方法，以增强函数</p><pre><code>var person = {  name: &quot;Nicholas&quot;,  friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]};var anotherPerson = createAnother(person);anotherPerson.sayHi(); //&quot;hi&quot;</code></pre><p>缺点（同原型式继承）：</p><ul><li>原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。</li><li>无法传递参数</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>结合借用构造函数传递参数和寄生模式实现继承</p><pre><code>function inheritPrototype(subType, superType){  var prototype = Object.create(superType.prototype); // 创建对象，创建父类原型的一个副本  prototype.constructor = subType;                    // 增强对象，弥补因重写原型而失去的默认的constructor 属性  subType.prototype = prototype;                      // 指定对象，将新创建的对象赋值给子类的原型}// 父类初始化实例属性和原型属性function SuperType(name){  this.name = name;  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];}SuperType.prototype.sayName = function(){  alert(this.name);};// 借用构造函数传递增强子类实例属性（支持传参和避免篡改）function SubType(name, age){  SuperType.call(this, name);  this.age = age;}// 将父类原型指向子类inheritPrototype(SubType, SuperType);// 新增子类原型属性SubType.prototype.sayAge = function(){  alert(this.age);}var instance1 = new SubType(&quot;xyc&quot;, 23);var instance2 = new SubType(&quot;lxy&quot;, 23);instance1.colors.push(&quot;2&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;2&quot;]instance1.colors.push(&quot;3&quot;); // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;3&quot;]</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c2c0109df5438?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code>上创建不必要的、多余的属性。于此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code><br><strong>这是最成熟的方法，也是现在库实现的方法</strong></p><h3 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h3><pre><code>function MyClass() {     SuperClass.call(this);     OtherSuperClass.call(this);}// 继承一个类MyClass.prototype = Object.create(SuperClass.prototype);// 混合其它Object.assign(MyClass.prototype, OtherSuperClass.prototype);// 重新指定constructorMyClass.prototype.constructor = MyClass;MyClass.prototype.myMethod = function() {     // do something};</code></pre><p><code>Object.assign</code>会把<code>OtherSuperClass</code>原型上的函数拷贝到<code>MyClass</code>原型上，使<code>MyClass</code>的所有实例都可用<code>OtherSuperClass</code>的方法。</p><h3 id="ES6类继承extends"><a href="#ES6类继承extends" class="headerlink" title="ES6类继承extends"></a>ES6类继承extends</h3><p>extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。</p><pre><code>class Rectangle {    // constructor    constructor(height, width) {        this.height = height;        this.width = width;    }    // Getter    get area() {        return this.calcArea()    }    // Method    calcArea() {        return this.height * this.width;    }}const rectangle = new Rectangle(10, 20);console.log(rectangle.area);// 输出 200-----------------------------------------------------------------// 继承class Square extends Rectangle {  constructor(length) {    super(length, length);    // 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。    this.name = &#39;Square&#39;;  }  get area() {    return this.height * this.width;  }}const square = new Square(10);console.log(square.area);// 输出 100</code></pre><p>extends继承的核心代码如下，其实现和上述的寄生组合式继承方式一样</p><pre><code>function _inherits(subType, superType) {    // 创建对象，创建父类原型的一个副本    // 增强对象，弥补因重写原型而失去的默认的constructor 属性    // 指定对象，将新创建的对象赋值给子类的原型    subType.prototype = Object.create(superType &amp;&amp; superType.prototype, {        constructor: {            value: subType,            enumerable: false,            writable: true,            configurable: true        }    });       if (superType) {        Object.setPrototypeOf             ? Object.setPrototypeOf(subType, superType)             : subType.__proto__ = superType;    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="函数声明和类声明的区别"><a href="#函数声明和类声明的区别" class="headerlink" title="函数声明和类声明的区别"></a>函数声明和类声明的区别</h4><p>函数声明会提升，类声明不会。首先需要声明你的类，然后访问它，否则像下面的代码会抛出一个ReferenceError。</p><pre><code>let p = new Rectangle(); // ReferenceErrorclass Rectangle {}</code></pre><h4 id="ES5继承和ES6继承的区别"><a href="#ES5继承和ES6继承的区别" class="headerlink" title="ES5继承和ES6继承的区别"></a>ES5继承和ES6继承的区别</h4><ul><li>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）.</li><li>ES6的继承有所不同，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
            <tag> 构造函数 </tag>
            
            <tag> 继承 </tag>
            
            <tag> new </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域</title>
      <link href="/2018/09/07/%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/2018/09/07/%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 this 的值，也被称为 This Binding。</p><p>2、LexicalEnvironment（词法环境） 组件被创建。</p><p>3、VariableEnvironment（变量环境） 组件被创建。<br>直接看伪代码可能更加直观</p><p>ExecutionContext = {<br>  ThisBinding = <this value>,     // 确定this<br>  LexicalEnvironment = { … },   // 词法环境<br>  VariableEnvironment = { … },  // 变量环境<br>}<br>This Binding<br>全局执行上下文中，this 的值指向全局对象，在浏览器中this 的值指向 window 对象，而在nodejs中指向这个文件的module对象。</this></p><p>函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数，具体内容会在【this全面解析】部分详解。</p><p>词法环境（Lexical Environment）<br>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><p>变量环境<br>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li>1.变量提升<pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li>2.函数提升<pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。<br>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）</p><h3 id="内存泄漏识别方法"><a href="#内存泄漏识别方法" class="headerlink" title="内存泄漏识别方法"></a>内存泄漏识别方法</h3><h4 id="浏览器方法"><a href="#浏览器方法" class="headerlink" title="浏览器方法"></a>浏览器方法</h4><p>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</p><h4 id="命令行方法"><a href="#命令行方法" class="headerlink" title="命令行方法"></a>命令行方法</h4><p>使用 Node 提供的 process.memoryUsage 方法。</p><pre><code>console.log(process.memoryUsage());// 输出{   rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈  heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的  heapUsed: 3449392,    // 用到的堆的部分  external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre><p>判断内存泄漏，以heapUsed字段为准。</p><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行栈 </tag>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/2018/09/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/07/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。</p><h2 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h2><p>typeof 对于基本类型，除了 null 都可以显示正确的类型<br><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c6ee7529bae2d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>000 开头代表是对象，然而 null 表示 为全零，所以将它错误的判断为 object 。</p><h2 id="instanceof-和-Object-prototype-toString-call"><a href="#instanceof-和-Object-prototype-toString-call" class="headerlink" title="instanceof 和 Object.prototype.toString.call"></a>instanceof 和 Object.prototype.toString.call</h2><p>typeof 无法判断数组，对象.<br>可以通过<code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[Object Type]</code> 的字符串。<br><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链 中是不是能找到类型的 <code>prototype</code>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="ToString负责处理非字符串到字符串的强制类型转换"><a href="#ToString负责处理非字符串到字符串的强制类型转换" class="headerlink" title="ToString负责处理非字符串到字符串的强制类型转换"></a><code>ToString</code>负责处理非字符串到字符串的强制类型转换</h3><p>null转换为’null’,undefined转换为’undefined’,其他基本类型都调用基本类型的包装对象属性toString()并返回值。</p><pre><code>const a = 123; const _a = new Number(123); console.log(String(a), _a.toString());               //&#39;123&#39; &#39;123&#39; 数字的字符串化遵循通用规则，但是极小极大数字使用指数形式const a = 1.07*1000*1000*1000*1000*1000*1000*1000;console.log(String(a));                               //&#39;1.07e+21&#39;</code></pre><p>对于普通对象来说，除非自行定义，否则<code>toString()</code>返回<code>Object.prototype.toString()</code>的值,其他对象有自己的<code>toString()</code>方法则调用自己的该方法.</p><pre><code>const b = {};console.log(String(b));                                //[object object]</code></pre><p>对于数组来说会转成以“，”拼接各项的字符串</p><pre><code>const arr = [{s:1},2,3]console.log(arr.toString())                           //&quot;[object Object],2,3&quot;</code></pre><h3 id="ToNumber负责处理非数字到数字的强制类型转换"><a href="#ToNumber负责处理非数字到数字的强制类型转换" class="headerlink" title="ToNumber负责处理非数字到数字的强制类型转换"></a><code>ToNumber</code>负责处理非数字到数字的强制类型转换</h3><p>true转换为1，false转换为0，undefined转换为NaN，null转换为0</p><pre><code>console.log(Number(null));                                //0 console.log(Number(undefined));                           //NaNconsole.log(Number(true));                                //1console.log(Number(false));                               //0</code></pre><p>对字符串的处理遵循数字常量的相关规定/语法，处理失败时返回NaN</p><pre><code>console.log(Number(&#39;123&#39;));                               //123console.log(Number(&#39;0b111&#39;));                             //7console.log(Number(&#39;0o123&#39;));                             //83console.log(Number(&#39;0x123&#39;));                             //291console.log(Number(&#39;123a&#39;));                              //NaNconsole.log(Number(&#39;a123&#39;));                              //NaN</code></pre><p>对象（包括数组）会首先按照<code>ToPrimitive</code>抽象操作被转换为相应的基本类型值，再按照前两条规则处理；如果某个对象即不存在<code>valueOf</code>方法也不存在<code>toString</code>方法，则会产生<code>TypeError</code>错误（例如Object.create(null)不存在以上两种方法）</p><pre><code>const arr = [1, 2, 3]; console.log(Number(arr));                               //NaNconsole.log(Number(arr.toString()));                    //NaNconst num = new Number(123);console.log(Number(num));                               //123console.log(Number(num.valueOf()));                     //123const bool = new Boolean(true);console.log(bool.valueOf());                           //trueconsole.log(Number(bool));                             //1console.log(Number(bool.valueOf()));                   //1const obj1 = {  toString:()=&gt;&quot;21&quot;}const obj2 = {  valueOf:()=&gt;&quot;42&quot;,  toString:()=&gt;&quot;21&quot;}const obj3 = {  a:1}console.log(Number(obj1));                              //21console.log(Number(obj2));                              //42console.log(obj3.toString());                           //[object Object]console.log(Number(obj3));                              //NaNconst obj = Object.create(null);console.log(Number(obj));                               //TypeError</code></pre><h3 id="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"><a href="#ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下" class="headerlink" title="ToBoolean负责处理非布尔值到布尔值的强制类型转换，规则如下"></a><code>ToBoolean</code>负责处理非布尔值到布尔值的强制类型转换，规则如下</h3><p>可以被转换为<code>false</code>的值（<code>undefined</code>，<code>null</code>，<code>false</code>， <code>0</code>和<code>NaN</code>，’’）</p><p>其他都被转换为true（切记：封装对象均被转为true）</p><h2 id="隐式强制类型转换"><a href="#隐式强制类型转换" class="headerlink" title="隐式强制类型转换"></a>隐式强制类型转换</h2><p>隐式强制类型转换为字符串</p><p>一元运算符加号（+）首先把非基本类型通过ToPrimitive抽象操作转换为基本类型，如果加号中的两项有一项是字符串，另一项则进行ToString操作，进行字符串拼接，如果是布尔值加数字，则对布尔进行ToNumber操作再求和</p><p>隐式强制类型转换为数字，通过一元运算符-、/、*转换，遵循ToNumber的抽象值操作规则</p><p>隐式强制类型转换为布尔值</p><p>if(..)语句中的条件判断表达式</p><p>for(..;..;..)语句的第二个条件判断表达式</p><p>while(..)和do..while(..)的条件判断表达式</p><p>?:中的条件判断表达式</p><p>逻辑运算符||和&amp;&amp;左边的操作数（a||b等同于a?a:b，a&amp;&amp;b等同于a?b:a）</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用栈</title>
      <link href="/2018/09/07/%E8%B0%83%E7%94%A8%E6%A0%88/"/>
      <url>/2018/09/07/%E8%B0%83%E7%94%A8%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>这期完全复刻木易老师的博客，因为写的很好 我这里只是自己复习，没有商用</p><p><a href="https://github.com/yygmind/blog" target="_blank" rel="noopener">木易老师博客地址</a></p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p><strong>执行上下文</strong>总共有三种类型：</p><p><strong>全局执行上下文</strong>：只有一个，浏览器中的全局对象就是 <code>window</code> 对象，this 指向这个全局对象。</p><p><strong>函数执行上下文</strong>：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。</p><p><strong>Eval 函数执行上下文</strong>： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用。</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，具有 <strong>LIFO</strong>（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。</p><p>首次运行JS代码时，会创建一个<strong>全局</strong>执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。</p><p>根据执行栈<strong>LIFO</strong>规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中<strong>Pop</strong>出，上下文控制权将移到当前执行栈的下一个执行上下文。</p><pre><code>function first() {    console.log(&#39;Inside first function&#39;);    second();    console.log(&#39;Again inside first function&#39;);  }function second() {    console.log(&#39;Inside second function&#39;);  }first();  console.log(&#39;Inside Global Execution Context&#39;);// Inside first function// Inside second function// Again inside first function// Inside Global Execution Context</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/8/22/16cb80e4579be263?w=1280&h=228&f=webp&s=13834" alt></p><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>执行上下文分两个阶段创建：<strong>1）创建阶段； 2）执行阶段</strong></p><p><strong>创建阶段</strong></p><p>1、确定 <code>this</code> 的值，也被称为 <strong>This Binding</strong>。</p><p>2、<strong>LexicalEnvironment（词法环境）</strong> 组件被创建。</p><p>3、<strong>VariableEnvironment（变量环境）</strong> 组件被创建。<br>直接看伪代码可能更加直观</p><pre><code>ExecutionContext = {    ThisBinding = &lt;this value&gt;,     // 确定this   LexicalEnvironment = { ... },   // 词法环境  VariableEnvironment = { ... },  // 变量环境}</code></pre><h3 id="This-Binding"><a href="#This-Binding" class="headerlink" title="This Binding"></a>This Binding</h3><p>全局执行上下文中，<code>this</code> 的值指向全局对象，在浏览器中<code>this</code> 的值指向 <code>window</code> 对象，而在nodejs中指向这个文件的<code>module</code>对象。</p><p>函数执行上下文中，<code>this</code> 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数.</p><h3 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h3><p>词法环境有两个组成部分</p><ul><li><p>1、环境记录：存储变量和函数声明的实际位置</p></li><li><p>2、对外部环境的引用：可以访问其外部词法环境</p></li></ul><p>词法环境有两种类型</p><ul><li><p>1、全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p></li><li><p>2、函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p></li></ul><p>直接看伪代码可能更加直观</p><pre><code>GlobalExectionContext = {  // 全局执行上下文  LexicalEnvironment: {          // 词法环境    EnvironmentRecord: {           // 环境记录      Type: &quot;Object&quot;,                 // 全局环境      // 标识符绑定在这里       outer: &lt;null&gt;                    // 对外部环境的引用  }  }FunctionExectionContext = { // 函数执行上下文  LexicalEnvironment: {        // 词法环境    EnvironmentRecord: {          // 环境记录      Type: &quot;Declarative&quot;,         // 函数环境      // 标识符绑定在这里               // 对外部环境的引用      outer: &lt;Global or outer function environment reference&gt;    }  }</code></pre><h3 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h3><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p><p>在 ES6 中，词法 环境和 变量 环境的区别在于前者用于存储<strong>函数声明和变量</strong>（ let 和 const ）绑定，而后者仅用于存储<strong>变量</strong>（ var ）绑定。</p><p>使用例子进行介绍</p><pre><code>let a = 20;  const b = 30;  var c;function multiply(e, f) {   var g = 20;   return e * f * g;  }c = multiply(20, 30);</code></pre><p>执行上下文如下所示</p><pre><code>GlobalExectionContext = {  ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        a: &lt; uninitialized &gt;,        b: &lt; uninitialized &gt;,        multiply: &lt; func &gt;      }      outer: &lt;null&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Object&quot;,        // 标识符绑定在这里        c: undefined,      }      outer: &lt;null&gt;    }  }FunctionExectionContext = {    ThisBinding: &lt;Global Object&gt;,  LexicalEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        Arguments: {0: 20, 1: 30, length: 2},      },      outer: &lt;GlobalLexicalEnvironment&gt;    },  VariableEnvironment: {      EnvironmentRecord: {        Type: &quot;Declarative&quot;,        // 标识符绑定在这里        g: undefined      },      outer: &lt;GlobalLexicalEnvironment&gt;    }  }</code></pre><h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><ul><li><p>1.变量提升</p><pre><code>console.log(num); //undefinedvar num = 1;</code></pre></li><li><p>2.函数提升</p><pre><code>foo();  // foo2var foo = function() {  console.log(&#39;foo1&#39;);}foo();  // foo1，foo重新赋值function foo() {  console.log(&#39;foo2&#39;);}foo(); // foo1</code></pre></li></ul><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>因为JS引擎创建了很多的执行上下文，所以JS引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>有如下两段代码，执行的结果是一样的，但是两段代码究竟有什么不同？</p><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f();}checkscope();</code></pre><pre><code>var scope = &quot;global scope&quot;;function checkscope(){    var scope = &quot;local scope&quot;;    function f(){        return scope;    }    return f;}checkscope()();</code></pre><p>答案是 执行上下文栈的变化不一样。</p><p>第一段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop();</code></pre><p>第二段代码：</p><pre><code>ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop();</code></pre><h2 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h2><p>在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p><p><strong>活动对象和变量对象</strong>的区别在于</p><ul><li>1、变量对象（VO）是规范上或者是JS引擎上实现的，并不能在JS环境中直接访问。</li><li>2、当进入到一个执行上下文后，这个变量对象才会被激活，所以叫活动对象（AO），这时候活动对象上的各种属性才能被访问。<br>调用函数时，会为其创建一个Arguments对象，并自动初始化局部变量arguments，指代该Arguments对象。所有作为参数传入的值都会成为Arguments对象的数组元素。</li></ul><p>执行过程<br>执行上下文的代码会分成两个阶段进行处理</p><ul><li><p>1、进入执行上下文</p></li><li><p>2、代码执行</p></li></ul><p>进入执行上下文<br>很明显，这个时候还没有执行代码</p><p>此时的变量对象会包括（如下顺序初始化）：</p><ul><li><p>1、函数的所有形参 (only函数上下文)：没有实参，属性值设为undefined。</p></li><li><p>2、函数声明：如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p></li><li><p>3、变量声明：如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性。<br>上代码就直观了</p><pre><code>function foo(a) {var b = 2;function c() {}var d = function() {};b = 3;}foo(1);</code></pre><p>对于上面的代码，这个时候的AO是</p><pre><code>AO = {  arguments: {      0: 1,      length: 1  },  a: 1,  b: undefined,  c: reference to function c(){},  d: undefined}</code></pre><p>形参arguments这时候已经有赋值了，但是变量还是undefined，只是初始化的值</p></li></ul><p>代码执行<br>这个阶段会顺序执行代码，修改变量对象的值，执行完成后AO如下</p><pre><code>AO = {    arguments: {        0: 1,        length: 1    },    a: 1,    b: 3,    c: reference to function c(){},    d: reference to FunctionExpression &quot;d&quot;}</code></pre><p>总结如下：</p><ul><li><p>1、全局上下文的变量对象初始化是全局对象</p></li><li><p>2、函数上下文的变量对象初始化只包括 Arguments 对象</p></li><li><p>3、在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p></li><li><p>4、在代码执行阶段，会再次修改变量对象的属性值</p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li>1.基本类型：–&gt; 栈内存（不包含闭包中的变量）</li><li>2.引用类型：–&gt; 堆内存</li></ul><p><strong>内存回收</strong></p><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><p><strong>局部变量和全局变量的销毁</strong></p><ul><li>局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li><li>全局变量：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li></ul><p>以Google的V8引擎为例，V8引擎中所有的JS对象都是通过<strong>堆</strong>来进行内存分配的</p><ul><li>初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</li><li>继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</li></ul><p>V8引擎对堆内存中的JS对象进行分代管理</p><ul><li>新生代：存活周期较短的JS对象，如临时变量、字符串等。</li><li>老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。</li></ul><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。</p><ul><li>1.引用计数（现代浏览器不再使用）</li><li>2.标记清除（常用）</li></ul><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有<strong>指向它的引用</strong>。如果没有其他对象指向它了，说明该对象已经不再需要了。</p><pre><code>// 创建一个对象person，他有两个指向属性age和name的引用var person = {    age: 12,    name: &#39;aaaa&#39;};person.name = null; // 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1;         //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null;           //原person对象已经没有引用，很快会被回收</code></pre><p>引用计数有一个致命的问题，那就是<strong>循环引用</strong></p><p>如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。</p><pre><code>function cycle() {    var o1 = {};    var o2 = {};    o1.a = o2;    o2.a = o1;     return &quot;cycle reference!&quot;}cycle();</code></pre><p>cycle函数执行完成之后，对象o1和o2实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。</p><p>但是IE依旧使用。</p><pre><code>var div = document.createElement(&quot;div&quot;);div.onclick = function() {    console.log(&quot;click&quot;);};</code></pre><p>上面的写法很常见，但是上面的例子就是一个循环引用。</p><p>变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。</p><h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。所以上面的例子就可以正确被垃圾回收处理了。</p><p>算法由以下几步组成：</p><ul><li><p>1、垃圾回收器创建了一个“roots”列表。roots 通常是代码中全局变量的引用。JavaScript 中，“window” 对象是一个全局变量，被当作 root 。window 对象总是存在，因此垃圾回收器可以检查它和它的所有子对象是否存在（即不是垃圾）；</p></li><li><p>2、所有的 roots 被检查和标记为激活（即不是垃圾）。所有的子对象也被递归地检查。从 root 开始的所有对象如果是可达的，它就不被当作垃圾。</p></li><li><p>3、所有未被标记的内存会被当做垃圾，收集器现在可以释放内存，归还给操作系统了。</p></li></ul><p>现代的垃圾回收器改良了算法，但是本质是相同的：可达内存被标记，其余的被当作垃圾回收。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）<br><strong>内存泄漏识别方法</strong></p><ul><li>1、<strong>浏览器方法</strong><br>打开开发者工具，选择 Memory<br>在右侧的Select profiling type字段里面勾选 timeline<br>点击左上角的录制按钮。<br>在页面上进行各种操作，模拟用户的使用情况。<br>一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。</li><li>2、<strong>命令行方法</strong><br>使用 Node 提供的 process.memoryUsage 方法。<pre><code>console.log(process.memoryUsage());// 输出{ rss: 27709440,        // resident set size，所有内存占用，包括指令区和堆栈heapTotal: 5685248,   // &quot;堆&quot;占用的内存，包括用到的和没用到的heapUsed: 3449392,    // 用到的堆的部分external: 8772         // V8 引擎内部的 C++ 对象占用的内存}</code></pre>判断内存泄漏，以heapUsed字段为准。</li></ul><p><strong>WeakMap</strong></p><p>ES6 新出的两种数据结构：<code>WeakSet</code> 和 <code>WeakMap</code>，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。</p><pre><code>const wm = new WeakMap();const element = document.getElementById(&#39;example&#39;);wm.set(element, &#39;some information&#39;);wm.get(element) // &quot;some information&quot;</code></pre><p>先新建一个 Weakmap 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。</p><h3 id="四种常见的JS内存泄漏"><a href="#四种常见的JS内存泄漏" class="headerlink" title="四种常见的JS内存泄漏"></a>四种常见的JS内存泄漏</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><p>未定义的变量会在全局对象创建一个新变量，如下。</p><pre><code>function foo(arg) {    bar = &quot;this is a hidden global variable&quot;;}函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。function foo(arg) {    window.bar = &quot;this is an explicit global variable&quot;;}另一个意外的全局变量可能由 this 创建。function foo() {    this.variable = &quot;potential accidental global&quot;;}// Foo 调用自己，this 指向了全局对象（window）// 而不是 undefinedfoo();</code></pre><p>解决方法：在 JavaScript 文件头部加上 ‘use strict’，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 <code>null</code> 或者重新定义。</p><h4 id="被遗忘的计时器或回调函数"><a href="#被遗忘的计时器或回调函数" class="headerlink" title="被遗忘的计时器或回调函数"></a>被遗忘的计时器或回调函数</h4><p>计时器setInterval代码很常见</p><pre><code>var someResource = getData();setInterval(function() {    var node = document.getElementById(&#39;Node&#39;);    if(node) {        // 处理 node 和 someResource        node.innerHTML = JSON.stringify(someResource));    }}, 1000);</code></pre><p>上面的例子表明，在节点node或者数据不再需要时，定时器依旧指向这些数据。所以哪怕当node节点被移除后，interval 仍旧存活并且垃圾回收器没办法回收，它的依赖也没办法被回收，除非终止定时器。</p><pre><code>var element = document.getElementById(&#39;button&#39;);function onClick(event) {    element.innerHTML = &#39;text&#39;;}element.addEventListener(&#39;click&#39;, onClick);</code></pre><p>对于上面观察者的例子，一旦它们不再需要（或者关联的对象变成不可达），明确地移除它们非常重要。老的 IE 6 是无法处理循环引用的。因为老版本的 IE 是无法检测 DOM 节点与 JavaScript 代码之间的循环引用，会导致内存泄漏。<br>但是，现代的浏览器（包括 IE 和 Microsoft Edge）使用了更先进的垃圾回收算法（标记清除），已经可以正确检测和处理循环引用了。即回收节点内存时，不必非要调用<code>removeEventListener</code>了。</p><h4 id="脱离-DOM-的引用"><a href="#脱离-DOM-的引用" class="headerlink" title="脱离 DOM 的引用"></a>脱离 DOM 的引用</h4><p>如果把DOM 存成字典（JSON 键值对）或者数组，此时，同样的 DOM 元素存在两个引用：一个在 DOM树中，另一个在字典中。那么将来需要把两个引用都清除。</p><pre><code>var elements = {    button: document.getElementById(&#39;button&#39;),    image: document.getElementById(&#39;image&#39;),    text: document.getElementById(&#39;text&#39;)};function doStuff() {    image.src = &#39;http://some.url/image&#39;;    button.click();    console.log(text.innerHTML);    // 更多逻辑}function removeButton() {    // 按钮是 body 的后代元素    document.body.removeChild(document.getElementById(&#39;button&#39;));    // 此时，仍旧存在一个全局的 #button 的引用    // elements 字典。button 元素仍旧在内存中，不能被 GC 回收。}</code></pre><p>如果代码中保存了表格某一个<code>&lt;td&gt;</code> 的引用。将来决定删除整个表格的时候，直觉认为 GC 会回收除了已保存的<code>&lt;td&gt;</code>以外的其它节点。实际情况并非如此：此 <code>&lt;td&gt;</code> 是表格的子节点，子元素与父元素是引用关系。由于代码保留了<code>&lt;td&gt;</code> 的引用，导致整个表格仍待在内存中。所以保存 DOM 元素引用的时候，要小心谨慎。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包的关键是匿名函数可以访问父级作用域的变量。</p><pre><code>var theThing = null;var replaceThing = function () {  var originalThing = theThing;  var unused = function () {    if (originalThing)      console.log(&quot;hi&quot;);  };  theThing = {    longStr: new Array(1000000).join(&#39;*&#39;),    someMethod: function () {      console.log(someMessage);    }  };};setInterval(replaceThing, 1000);</code></pre><p>每次调用 replaceThing ，theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包（先前的 replaceThing 又调用了 theThing ）。someMethod 可以通过 theThing 使用，someMethod 与 unused 分享闭包作用域，尽管 unused 从未使用，它引用的 originalThing 迫使它保留在内存中（防止被回收）。</p><p>解决方法：在 replaceThing 的最后添加 originalThing = null 。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> 提升 </tag>
            
            <tag> 调用栈 </tag>
            
            <tag> 内存泄漏 </tag>
            
            <tag> 上下文 </tag>
            
            <tag> 垃圾回收算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
